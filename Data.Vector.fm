import Data.Fin
import Data.Nat
import Induction.Nat
import Relation.Equality

T Vector {A : Type} (len : Nat)
| vcons
  { ~len : Nat
  , head : A
  , tail : Vector(A, len)
  } (succ(len))
| vnil (zero)

// ::::::::::::::::::::::
// :: Simple functions ::
// ::::::::::::::::::::::

vhead : {~T : Type, ~n : Nat, vector : Vector(T, succ(n))} -> T
  (case/Vector vector
  | vcons => {~e} head
  | vnil  => {~e} absurd(zero_not_succ(~n,~sym(~e)), ~T)
  : {~e : len == succ(n)} -> T
  )(~refl(~succ(n)))

vtail : {~T : Type, ~n : Nat , vector : Vector(T, succ(n))} -> Vector(T, n)
  (case/Vector vector
  | vcons => {~e} tail :: rewrite len in Vector(T,len) with cong_pred(len, n, e)
  | vnil  => {~e} absurd(zero_not_succ(~n,~sym(~e)), ~Vector(T,n))
  : {~e : len == succ(n)} -> Vector(T, n)
  )(~refl(~succ(n)))

vtake : {~T : Type, ~n : Nat, vector : Vector(T, succ(n))} -> [:T, Vector(T,n)]
  (case/Vector vector
  | vcons => {~e} [head, tail :: rewrite m in Vector(T,m) with cong_pred(len,n,e)]
  | vnil  => {~e} absurd(zero_not_succ(~n,~sym(~e)), ~[:T, Vector(T,n)])
  : {~e : len == succ(n)} -> [:T, Vector(T,n)]
  )(~refl(~succ(n)))

// :::::::::::::::::::::::::
// :: Recursive Functions ::
// :::::::::::::::::::::::::

// Returns the same vector
#vsame*N : !{~A : Type, vector : Vector(A, <nat(N)>)} -> Vector(A, <nat(N)>)
  (case/Vector vector
  | vcons => {vsame} vcons(~A, ~len, head, vsame(~A, tail))
  | vnil  => {vsame} vnil(~A)
  : { vsame : {~A : Type, vector : Vector(A, pred(len))} -> Vector(A, pred(len))
    } -> Vector(A, len))(vsame)
halt: vnil(~A)

// Allocates a Vec with given length
#valloc*N : {~A : Type, x : !A} -> !Vector(A, <nat(N)>)
  vcons(~A, ~<nat(N)>, x, valloc)
halt: vnil(~A)

// Creates a vector with `N` ascending words starting from `idx` 
#vrange*N : !{init : Word} -> Vector(Word, <nat(N)>)
  vcons(~Word, ~<nat(N)>, init, vrange(init + 1))
halt: vnil(~Word)

// Applies a function to every element of a vector
#vmap*N :
  { ~A : Type
  , ~B : Type
  , f : !A -> B
  } -> ! {vector : Vector(A, <nat(N)>)} -> Vector(B, <nat(N)>)
  (case/Vector vector
  | vcons => {~e}
    let tail = tail       :: rewrite x in Vector(A, x) with e
    let tail = vmap(tail) :: rewrite x in Vector(B, x) with sym(~e)
    vcons(~B, ~len, f(head), tail)
  | vnil => {~e} vnil(~B)
  : {~e : pred(len) == <nat(N)>} -> Vector(B, len)
  )(~refl(~<nat(N)>))
halt: vnil(~B)

// Concatenates two vectors
#vconcat*N :
  !{ ~A : Type
  , xs : Vector(A, <nat(N)>)
  , m : Nat
  , ys : Vector(A, m)
  } -> Vector(A, <add_ind(N)>(m))
  (case/Vector xs
  | vcons => {~e}
    let tail = tail :: rewrite x in Vector(A, x) with cong_pred(len, <nat(N)>, e)
    vcons(~A, ~<add_ind(N)>(m), head, vconcat(~A, tail, m, ys))
  | vnil => {~e}
    absurd(zero_not_succ(~<nat(N)>, ~sym(~e)), ~Vector(A, <add_ind(step(N))>(m)))
  : {~e : len == succ(<nat(N)>)} -> Vector(A, <add_ind(step(N))>(m))
  )(~refl(~succ(<nat(N)>)))
halt: ys
