import Data.Fin
import Data.Nat
import Induction.Nat
import Relation.Equality

T Vector {A : Type} (len : Nat)
| vcons
  { ~len : Nat
  , head : A
  , tail : Vector(A, len)
  } (succ(len))
| vnil (zero)

// ::::::::::::::::::::::
// :: Simple functions ::
// ::::::::::::::::::::::

vhead : {~T : Type, ~n : Nat, xs : Vector(T, succ(n))} -> T
  case/Vector xs
  with xs.len == succ(n)
  | vcons => xs.head
  | vnil  => absurd(succ_isnt_zero(~n, ~xs.len.equal), ~T)
  : T

vtail : {~T : Type, ~n : Nat , xs : Vector(T, succ(n))} -> Vector(T, n)
  case/Vector xs
  with xs.len == succ(n)
  | vcons => xs.tail :: rewrite xs.len in Vector(T, xs.len) with cong(~pred, ~sym(~xs.len.equal))
  | vnil  => absurd(succ_isnt_zero(~n,~xs.len.equal), ~Vector(T,n))
  : Vector(T, n)

vtake : {~T : Type, ~n : Nat, xs : Vector(T, succ(n))} -> [:T, Vector(T,n)]
  case/Vector xs
  with xs.len == succ(n)
  | vcons => [xs.head, xs.tail :: rewrite m in Vector(T,m) with cong(~pred, ~sym(~xs.len.equal))]
  | vnil  => absurd(succ_isnt_zero(~n, ~xs.len.equal), ~[:T, Vector(T,n)])
  : [:T, Vector(T,n)]

// :::::::::::::::::::::::::
// :: Recursive Functions ::
// :::::::::::::::::::::::::

// Returns the same vector
#vsame*N : !{~A : Type, xs : Vector(A, <nat(N)>)} -> Vector(A, <nat(N)>)
  case/Vector xs
  with xs.len == <nat(step(N))>
  | vcons => 
    let tail = xs.tail         :: rewrite x in Vector(A, x) with cong(~pred, ~sym(~xs.len.equal))
    let tail = vsame(~A, tail) :: rewrite x in Vector(A, x) with cong(~pred, ~xs.len.equal)
    vcons(~A, ~xs.len, xs.head, tail)
  | vnil  => vnil(~A)
  : Vector(A, xs.len)
halt: vnil(~A)

// Allocates a Vec with given length
#valloc*N : {~A : Type, x : !A} -> !Vector(A, <nat(N)>)
  vcons(~A, ~<nat(N)>, x, valloc)
halt: vnil(~A)

// Creates a vector with `N` ascending words starting from `idx` 
#vrange*N : !{init : Word} -> Vector(Word, <nat(N)>)
  vcons(~Word, ~<nat(N)>, init, vrange(init + 1))
halt: vnil(~Word)

// Applies a function to every element of a vector
#vmap*N : {~A : Type, ~B : Type, f : !A -> B} -> ! {xs : Vector(A, <nat(N)>)} -> Vector(B, <nat(N)>)
  case/Vector xs
  with xs.len == <nat(step(N))>
  | vcons =>
    let tail = xs.tail    :: rewrite x in Vector(A, x) with cong(~pred, ~sym(~xs.len.equal))
    let tail = vmap(tail) :: rewrite x in Vector(B, x) with cong(~pred, ~xs.len.equal)
    vcons(~B, ~xs.len, f(xs.head), tail)
  | vnil =>
    vnil(~B)
  : Vector(B, xs.len)
halt: vnil(~B)

// Concatenates two vectors
#vconcat*N : !{~A : Type, xs : Vector(A, <nat(N)>), m : Nat, ys : Vector(A, m)} -> Vector(A, <add_ind(N)>(m))
  case/Vector xs
  with xs.len == <nat(step(N))>
  | vcons =>
    let tail = xs.tail :: rewrite x in Vector(A, x) with cong(~pred, ~sym(~xs.len.equal))
    let tail = vconcat(~A, tail, m, ys)
    vcons(~A, ~<add_ind(N)>(m), xs.head, tail)
  | vnil =>
    absurd(succ_isnt_zero(~<nat(N)>, ~xs.len.equal), ~Vector(A, <add_ind(step(N))>(m)))
  : Vector(A, <add_ind(step(N))>(m))
halt: ys
