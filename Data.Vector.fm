import Data.Fin
import Data.Nat
import Data.Unit
import Induction.Nat
//import Relation.Equality

T Vector {A : Type} (len : Nat)
| vcons
  { ~len : Nat
  , head : A
  , tail : Vector(A, len)
  } (succ(len))
| vnil (zero)

// ::::::::::::::::::::::
// :: Simple functions ::
// ::::::::::::::::::::::

vhead : {~T : Type, ~len : Nat, vector : Vector(T, succ(len))} -> T
  case/Vector vector
  | vcons  => head
  | vnil   => 0
  : case/Nat len | succ => T | zero => Word : Type

vtail : {~T : Type, ~len : Nat, vector : Vector(T, succ(len))} -> Vector(T, len)
  case/Vector vector
  | vcons => tail
  | vnil  => unit
  : case/Nat len | succ => Vector(T, pred) | zero => Unit : Type

vtake : {~T : Type, ~len : Nat, vector : Vector(T, succ(len))} -> [x : T, Vector(T, len)]
  case/Vector vector
  | vcons => [head, tail]
  | vnil  => unit
  : case/Nat len | succ => [x : T, Vector(T, pred)] | zero => Unit : Type

// :::::::::::::::::::::::::
// :: Recursive Functions ::
// :::::::::::::::::::::::::

// Allocates a Vec with given length
#alloc*N : {~A : Type, x : !A} -> !Vector(A, <nat(N)>)
  vcons(~A, ~<nat(N)>, x, alloc)
halt: vnil(~A)
