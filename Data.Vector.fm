import Data.Fin
import Data.Nat
import Induction.Nat
import Relation.Equality

// A vector is a list with a statically known length
T Vector {A : Type} (len : Nat)
| vcons {~len : Nat, head : A, tail : Vector(A, len)} (succ(len))
| vnil                                                (zero)

// ::::::::::::::::::::::
// :: Simple functions ::
// ::::::::::::::::::::::

// A type-safe "head" that returns the first element of a non-empty vector
// - On the `vcons` case, return the vector's head
// - On the `vnil` case, prove it is unreachable, since `xs.len > 0`
vhead : {~T : Type, ~n : Nat, xs : Vector(T, succ(n))} -> T
  case/Vector xs
  + note e : xs.len is succ(n)
  | vcons => xs.head
  | vnil  => absurd(zero_isnt_succ(~n, e), ~T) 
  : T

// Returns all but the first element of a non-empty vector
vtail : {~T : Type, ~n : Nat , xs : Vector(T, succ(n))} -> Vector(T, n)
  case/Vector xs
  + note e : xs.len is succ(n)
  | vcons => xs.tail :: rewrite xs.len in Vector(T, xs.len) with cong(~pred, e)
  | vnil  => absurd(succ_isnt_zero(~n,sym(e)), ~Vector(T,n))
  : Vector(T, n)

// Returns a pair with the head and the tail of a non-epty vector
vtake : {~T : Type, ~n : Nat, xs : Vector(T, succ(n))} -> [:T, Vector(T,n)]
  case/Vector xs
  + note e : xs.len is succ(n)
  | vcons => [xs.head, xs.tail :: rewrite m in Vector(T,m) with cong(~pred, e)]
  | vnil  => absurd(succ_isnt_zero(~n, sym(e)), ~[:T, Vector(T,n)])
  : [:T, Vector(T,n)]

// :::::::::::::::::::::::::
// :: Recursive Functions ::
// :::::::::::::::::::::::::

// Returns the same vector
#vsame*N : !{~A : Type, xs : Vector(A, <nat(N)>)} -> Vector(A, <nat(N)>)
  case/Vector xs
  + note e : pred(xs.len) is <nat(N)>
  | vcons => 
    let tail = xs.tail         :: rewrite x in Vector(A, x) with e
    let tail = vsame(~A, tail) :: rewrite x in Vector(A, x) with sym(e)
    vcons(~A, ~xs.len, xs.head, tail)
  | vnil  => vnil(~A)
  : Vector(A, xs.len)
halt: vnil(~A)

// Allocates a Vec with given length
#valloc*N : {~A : Type, x : !A} -> !Vector(A, <nat(N)>)
  vcons(~A, ~<nat(N)>, x, valloc)
halt: vnil(~A)

// Creates a vector with `N` ascending words starting from `idx` 
#vrange*N : !{init : Word} -> Vector(Word, <nat(N)>)
  vcons(~Word, ~<nat(N)>, init, vrange(init + 1))
halt: vnil(~Word)

// Applies a function to every element of a vector
#vmap*N : {~A : Type, ~B : Type, f : !A -> B} -> ! {xs : Vector(A, <nat(N)>)} -> Vector(B, <nat(N)>)
  case/Vector xs
  + note e : pred(xs.len) is <nat(N)>
  | vcons =>
    let tail = xs.tail    :: rewrite x in Vector(A, x) with e
    let tail = vmap(tail) :: rewrite x in Vector(B, x) with sym(e)
    vcons(~B, ~xs.len, f(xs.head), tail)
  | vnil =>
    vnil(~B)
  : Vector(B, xs.len)
halt: vnil(~B)

// Concatenates two vectors
#vconcat*N : !{~A : Type, xs : Vector(A, <nat(N)>), m : Nat, ys : Vector(A, m)} -> Vector(A, <add_ind(N)>(m))
  case/Vector xs
  + note e : xs.len is <nat(step(N))>
  | vcons =>
    let tail = xs.tail :: rewrite x in Vector(A, x) with cong(~pred, e)
    let tail = vconcat(~A, tail, m, ys)
    vcons(~A, ~<add_ind(N)>(m), xs.head, tail)
  | vnil =>
    absurd(succ_isnt_zero(~<nat(N)>, sym(e)), ~Vector(A, <add_ind(step(N))>(m)))
  : Vector(A, <add_ind(step(N))>(m))
halt: ys
