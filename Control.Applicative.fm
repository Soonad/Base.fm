import Data.Function

T Applicative {M : Type -> Type, s : {A : Type} -> Setoid(M(A))}
| applicative

  // A way to wrap values
  { pure :
    { ~A : Type
    , x  : A
    } -> M(A)

  // A way to apply wrapped functions to wrapped values
  , apply :
    { ~A : Type
    , ~B : Type
    , mf : M(A -> B)
    , ma : M(A)
    } -> M(B)

  // wrapped identity is the same as unwrapped identity
  , identity :
    { ~A : Type
    , ma : M(A)
    } -> case/Setoid s(A) as s | setoid =>
           s.R(apply(~A, ~A, pure(~(A -> A), id(~A)), ma), ma)
         : Type

  // wrapped function composition is the same as unwrapped composition
  , composition :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , u  : M(B -> C)
    , v  : M(A -> B)
    , w  : M(A)
    } -> let cmp = pure(~((B -> C) -> (A -> B) -> A -> C), compose(~A,~B,~C))
         let a1  = apply(~A, ~C)
         let a2  = apply(~(A -> B), ~(A -> C))
         let a3  = apply(~(B -> C), ~((A -> B) -> A -> C))
         let a4  = apply(~B, ~C)
         let a5  = apply(~A, ~B)
         case/Setoid s(C) as s | setoid =>
           s.R(a1(a2(a3(cmp, u),v),w), a4(u, a5(v, w)))
         : Type

  // applying a wrapped function to a wrapped value is the same unwrapped
  // function application
  , homomorphism :
    { ~A : Type
    , ~B : Type
    , f  : A -> B
    , x  : A
    } -> case/Setoid s(B) as s | setoid =>
          s.R(apply(~A, ~B, pure(~(A -> B), f), pure(~A, x)), pure(~B, f(x)))
         : Type

  // wrapped piping or flipped application behaves the same as unwrapped piping
  , interchange :
    { ~A : Type
    , ~B : Type
    , f : M(A -> B)
    , x : A
    } -> case/Setoid s(B) as s | setoid =>
           s.R( apply(~A, ~B, f, pure(~A, x))
              , apply(~(A -> B), ~B, pure(~((A -> B) -> B), pipe(~A,~B,x)), f)
              )
         : Type
  }

fun.Applicative : {R : Type} -> Applicative(Fun(!R), feq(!R))
  let pure = {~A,x} const(~!R,~A,x)
  let apply = {~A,~B,mrf,mra,r}
    dup r = r
    mrf(#r,mra(#r))
  let ident = {~A,mra,r}
    dup r = r
    const_id(~!R,~A,#r,mra(#r))
  applicative(~Fun(!R),~feq(!R),pure,apply,ident,?c,?h,?in)


const_id : {~A : Type, ~B : Type, a : A, b : B} -> 
  const(~A, ~(B -> B), id(~B),a)(b) == b
  refl(~b)
