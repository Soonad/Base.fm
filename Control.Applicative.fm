import Data.Function as F

T Applicative {M : Type -> Type}
| applicative

  // A way to wrap values
  { pure :
    { ~A : Type
    , x  : A
    } -> M(A)

  // A way to apply wrapped functions to wrapped values
  , apply :
    { ~A : Type
    , ~B : Type
    , mf : M(A -> B)
    , ma : M(A)
    } -> M(B)

  // wrapped identity is the same as unwrapped identity
  , identity :
    { ~A : Type
    , ma : M(A)
    } -> apply(~A, ~A, pure(~(A -> A), F/id(~A)), ma) == ma

  // wrapped function composition is the same as unwrapped composition
  , composition :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , u  : M(B -> C)
    , v  : M(A -> B)
    , w  : M(A)
    } -> let U = B -> C; let V = A -> B; let AC = A -> C;
         apply(~B, ~C, u, apply(~A, ~B, v, w)) ==
         apply(
           ~A
         , ~C
         , apply(
             ~V
           , ~AC
           , apply(~U, ~V -> AC, pure(~(U -> V -> AC), F/compose(~A,~B,~C)), u)
           , v
           )
         , w
         )

  // applying a wrapped function to a wrapped value is the same unwrapped
  // function application
  , homomorphism :
    { ~A : Type
    , ~B : Type
    , f  : A -> B
    , x  : A
    } -> apply(~A, ~B, pure(~(A -> B), f), pure(~A, x)) == pure(~B, f(x))

  // wrapped piping or flipped application behaves the same as unwrapped piping
  , interchange :
    { ~A : Type
    , ~B : Type
    , f : M(A -> B)
    , x : A
    } -> apply(~A, ~B, f, pure(~A, x)) ==
         apply(~(A -> B), ~B, pure(~((A -> B) -> B), F/pipe(~A,~B,x)), f)
  }
