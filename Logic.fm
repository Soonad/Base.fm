// The uninhabited type
T Empty

// From falsehood, everything follows
absurd : {e : Empty, P : Type} -> P; case/Empty e : P

// A false proposition returns a falsehood
Not : {P : Type} -> Type; {x : P} -> Empty

// Non-contradiction
Explosion : {A : Type, x : A, nx : Not(A)} -> Empty; nx(x)

// Modus ponens
Affirms: {A : Type, B : Type, implies : A -> B, a : A} -> B; implies(a)

// Modus tollens
Denies: {A : Type, B : Type, implies : A -> B, nb : Not(B)} -> Not(A)
  {x : A} nb(implies(x))

// Conjunction
T And<A : Type, B: Type>
| mkAnd { left : A, right : B}

dupAnd : {~A:Type} -> Type; And(A,A)

// Disjunction
T Or<A : Type, B: Type>
| mkLeft {left : A}
| mkRight {right : B}

// Disjunction elimination
orByCases : {~A : Type, ~B : Type, P : Or(A,B) -> Type
         , fromLeft : {l : A} -> P(mkLeft<A,B>(l))
         , fromRight : {r : B} -> P(mkRight<A,B>(r))
         , case or : Or(A,B)
         } -> P(or);
| mkLeft  => fromLeft(or.left)
| mkRight => fromRight(or.right)

// Biconditional
T Iff<A : Type, B : Type>
| mkIff { if : A -> B, onlyif : B -> A}

// Disjunctive syllogism (modus tollendo ponens)
orSyllogism : {~A : Type, ~B : Type, case orAB : Or(A,B), negA : Not(A)} -> B
| mkLeft => absurd(negA(orAB.left), B)
| mkRight => orAB.right

// Hypothetical syllogism
chainRule : {~A : Type, ~B : Type, ~C : Type, f : A -> B, g : B -> C} -> A -> C
  {x : A} g(f(x))
