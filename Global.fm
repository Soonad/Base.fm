// Congruence of the equality primitive (`a == b` implies `f(a) == f(b)`)
cong : {~A : Type, ~B : Type, ~a : A, ~b : A, ~f : {a : A} -> B, ~e : <a == b>} -> <f(a) == f(b)>
  rewrite<e>{x in <f(a) == f(x)>}(refl<f(a)>)

// Removes a box from an erased term
open : {~A : Type, x : !A} -> A
  dup x = x
  x

// Creates a boxed version of a function (from `A -> A` to `!A -> !A`)
boxed : {~A : Type, f : !{x : A} -> A, x : !A} -> !A
  dup f = f
  dup x = x
  # f(x)

// Rec is just the inductive Parigot-Nat (erased to Church-Nat). It has this
// name because it can be used to fuel recursive functions. It is encoded
// manually because the datatype syntax can't express a boxed return type, nor
// use P() inside constructors yet.
Rec : Type
  $ self {
   ~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(call(n))
  , S : ! P(halt)
  }  -> ! P(self)

call : {n : Rec} -> Rec
  new Rec {~P, C, S} =>
  dup C = C
  dup S = S
  dup A = (%n)(~P, #C, #S)
  # C(~n, A)

halt : Rec
  new Rec {~P, C, S} =>
  S

// This "fuels" recursive functions. Here, I use `256` (defined below),
// which gives us a "bound" of 256 calls per recursive function. This can be
// changed to be a very large number (i.e., 2^64 for example).
rec : {~T : Type, call : !{x : T} -> T, halt : !T} -> !T
  dup call = call
  dup halt = halt
  (%r256)(~{r} => T, #{~n} => call, #halt)

// Since `Rec` is just the type of the inductive hypothesis wrapped on self,
// induction itself is just identity as usual.
induce : {n : Rec} -> 
  {~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(call(n))
  , S : ! P(halt)
  } -> ! P(n)
  %n

twice : {n : Rec} -> Rec
  new Rec {~P, CALL, HALT}
  dup CALL = CALL
  dup HALT = HALT
  let moti = {n} => P(twice(n))
  let CALL = # {~n, i} => CALL(~call(twice(n)), CALL(~twice(n), i))
  let HALT = # HALT
  (%n)(~moti, CALL, HALT)

r256 : Rec
  twice(twice(twice(twice(
  twice(twice(twice(twice(
  call(halt)))))))))

// Runtime fusion on repeated not
main
  rec
