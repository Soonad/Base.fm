import Base

// # Dependent motives

// In Formality, the type returned by a case expression can depend on the
// matched value. For example, we can do this:

motives.example_0 : Word
  case/Bool true as x
  | true  => 42
  | false => "hello"
  : case/Bool x
    | true  => Word
    | false => String
    : Type

// While strange-looking, this is prefectly logical and well-typed. The reason
// this works is that, when checking the type of a case expression, Formality
// first specializes the motive for every possible branch to determine “what it
// demands”. In this case, it demands a Word on the true branch, and a `String`
// on the false branch. If you satisfy every demand, then it determines the
// type of the whole case expression by specializing the motive using actual
// matched value. In this case, we matched on true, so it returns Word.

// This has many interesting effects and applications.


// ## Functions with different return types

// We could write a function that returns different types based on its input:

diff_return.example_0 : {case b : Bool} -> case/Bool b | true => Word | false => String : Type
| true  => 42
| false => "hello"

diff_return.example_0_test : Word
  diff_return.example_0(true) + diff_return.example_0(true)

// Note this is not the same as returning `Either`, which is done in Haskell when
// we want to return different types, needing an extra pattern-match every time
// you call the function. Here, that’s not necessary, because foo really
// returns different types based on its input. Thanks to dependent types,
// Formality can statically determine if you’re doing the right thing, so,
// replacing `diff_return.example_0(true)` by `diff_return.example_0(false)` would be a type error.


// ## Proving absurds with Empty

// Another interesting example comes from the `Empty` datatype:

// {- From Data.Empty -}
T Empty

// Its code isn’t incomplete, the datatype has zero constructors. This means it
// is impossible to construct a term t with type `Empty`, but we can still accept
// it as a function argument. So, what happens if we pattern match against it?

// absurd.example_0 : {x : Empty} -> ?
//   case/Empty
//   : ?

// The answer is: we can replace `?` by anything, and the program will check.
// That’s because we technically proved all the demanded cases, so Formality
// just returns the motive directly as the type of this case expression. That
// allows us to write a function that returns something absurd:

absurd.example_1 : {e : Empty} -> 1 == 2
  case/Empty e
  : 1 == 2

// If we managed to call it, we’d have a proof that `1 == 2`, which is absurd,
// making Formality inconsistent. But this is fine: `absurd.example_1` can’t ever be
// called, because we can’t construct a value of type `Empty`. This is pretty
// useful, so we have a base-lib function that, given an element of `Empty`,
// returns any absurd type:

// {- From Data.Empty -}
absurd.example2 : {e : Empty, ~P : Type} -> P
  case/Empty e
  : P

// The opposite holds too: given an absurd equality, we can make an element of
// type `Empty`. Here is an example:

// {- From Data.Bool -}
absurd.example3 : {e : true == false} -> Empty
  unit :: rewrite x
    in case/Bool x
       | true  => Unit
       | false => Empty
       : Type
    with e

// As an exercise, convince yourself why this works.


// ## Unreachable branches with equality notes

// unreach_branch.example_0a : Word
//   case/Bool true
//   | true  => 10
//   | false => ?
//   : Word

// Here, we’re matching against true, so we know the false case is unreachable,
// but we still need to fill it with something. In this case, we could write
// any number, but that’s not always possible. In those cases, equality notes
// can be helpful:

unreach_branch.example_0b : Word
  case/Bool true as x
  + note e : x is true
  | true  => 10
  | false => absurd(false_isnt_true(e), ~Word)
  : Word

// The `+ note e : x == true` syntax reminds Formality that `x == true`, making it
// specialize `x` on each branch, giving you an `e : true == true` on the `true`
// branch, and an `e : false == true` on the false branch. Since `false == true` is
// absurd, we know the `false` branch is unreachable and, thus, can fill it by
// exploiting the absurd function above, without writing any number.

// To desugar an equality note, Formality simply adds an extra, erased equality
// argument:

unreach_branch.example_0c
  (case/Bool true as x
  | true  => {~e} 10
  | false => {~e} absurd(false_isnt_true(e), ~Word)
  : {~e : x == true} -> Word)(~refl(~true))

// Notice that the left side of the equality note is allowed to access the
// matched value (`x`), while the right side is used to build the refl proof.



