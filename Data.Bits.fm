import Induction.Nat open
import Relation.Equality open

T Bits
| b0 {pred : Bits}
| b1 {pred : Bits}
| be

!bnot*n : !{case bits : Bits} -> Bits
  | b0 => b1(bnot(bits.pred))
  | b1 => b0(bnot(bits.pred))
  | be => be
  * bits

!bnot.theo*n : !{case bits : Bits} -> <bnot*n>(<bnot*n>(bits)) == bits
| b0   => cong(~Bits, ~Bits, ~<bnot*n>(<bnot*n>(bits.pred)), ~bits.pred, ~b0, ~bnot.theo(bits.pred))
| b1   => cong(~Bits, ~Bits, ~<bnot*n>(<bnot*n>(bits.pred)), ~bits.pred, ~b1, ~bnot.theo(bits.pred))
| be   => refl(~be)
* refl(~bits)
