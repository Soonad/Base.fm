// Operations : A -> A -> A

Associative : {A : Type, f : A -> A -> A} -> Type;
  {x : A, y : A, z : A } -> f(f(x,y),z) == f(x,f(y,z))

Commutative : {A : Type, f : A -> A -> A} -> Type
  {x : A, y : A} -> f(x,y) == f(y,x)

LeftDistributive : {A : Type, f : A -> A -> A, g : A -> A -> A} -> Type
  {x : A, y : A, z : A} -> f(x, g(y,z)) == g(f(x,y),f(x,z))

RightDistributive : {A : Type, f : A -> A -> A, g : A -> A -> A} -> Type
  {x : A, y : A, z : A} -> f(g(y,z), x) == g(f(y,x),f(z,x))

T Distributive<A : Type, f : A -> A -> A, g : A -> A -> A>
| mkDistributive { left : LeftDistributive(A,f,g)
                 , right : RightDistributive(A,f,g)
                 }

// Properties of Elements

LeftIdentity : {A : Type, f : A -> A -> A, e : A} -> Type;
  {y : A} -> f(e,y) == y

RightIdentity : {A : Type, f : A -> A -> A, e : A} -> Type;
  {y : A} -> f(y,e) == y

T Identity<A : Type, f : A -> A -> A, e : A>
| mkIdentity { left : LeftIdentity(A,f,e), right : RightIdentity(A,f,e)}

LeftInverse : {A : Type, f : A -> A -> A, e: A, p : Identity(A,f,e)} -> Type;
  {y : A} -> [x : A, f(x,y) == e]

RightInverse : {A : Type, f : A -> A -> A, e: A, p : Identity(A,f,e)} -> Type;
  {y : A} -> [x : A, f(y,x) == e]

Inverse: {A : Type, f : A -> A -> A, e : A, p : Identity(A,f,e)} -> Type
  {y : A} -> [x : A, [:f(y,x) == e, f(x,y) == e]]

// Structures

T Magma<A : Type>
| mkMagma { f : A -> A -> A }

T Semigroup<A : Type>
| mkSemigroup { f : A -> A -> A, semigroup1 : Associative(A,f)}

T Quasigroup<A : Type>
| mkQuasigroup
  { f : A -> A -> A
  , quasigroup1 : {a : A, b : A} -> [:[x : A,f(a,x) == b],[y : A,f(y,a) == b]]
  }

T Loop<A : Type>
| mkLoop
  { f : A -> A -> A
  , e : A
  , loop1 : Identity(A,f,e)
  , loop2 : Inverse(A,f,e,loop1)
  }

T InverseSemigroup<A : Type>
| mkInverseSemigroup 
  { f : A -> A -> A
  , inverseSemigroup1 : Associative(A,f)
  , inverseSemigroup2 : {x : A} -> [y : A,[:x == f(x,f(y,x)),y == f(y,f(x,y))]]
  }

T Monoid<A : Type>
| mkMonoid 
  { f : A -> A -> A
  , e : A
  , monoid1 : Associative(A,f)
  , monoid2 : Identity(A,f,e)
  }

T Group<A : Type>
| mkGroup
  { f : A -> A -> A
  , e : A
  , group1 : Associative(A,f)
  , group2 : Identity(A,f,e)
  , group3 : Inverse(A,f,e, group2)
  }

T Abelian<A : Type>
| mkAbelian
  { f : A -> A -> A
  , e : A
  , abelian1 : Associative(A,f)
  , abelian2 : Identity(A,f,e)
  , abelian3 : Inverse(A,f,e,abelian2)
  , abelian4 : Commutative(A,f)
  }
