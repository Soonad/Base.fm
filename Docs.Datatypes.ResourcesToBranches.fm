import Base@0

// Moving resources to branches
// ----------------------------

// Since Formality functions are affine, you can’t use an argument more than once. So, for example, the function below isn’t allowed:

branches.example_0a : {a : Bool, b : Bool} -> Bool
  case/Bool a
  | true  => b
  | false => not(b)
  : Bool

// In this case in particular, you used b in two different branches, so you shouldn’t need to copy it. You can fix it with the move keyword:

branches.example_0b : {a : Bool, b : Bool} -> Bool
  case/Bool a
  + move b : Bool
  | true  => b
  | false => not(b)
  : Bool

// Under the hoods, this is desugared to an extra lambda on each branch:

branches.example_0c : {a : Bool, b : Bool} -> Bool
  (case/Bool a
  | true  => {b} b
  | false => {b} not(b)
  : Bool -> Bool)(b)

// When using case arguments, moves are added automatically:

branches.example_0d : {case a : Bool, b : Bool} -> Bool
| true  => b
| false => not(b)

// As you can see, the version using case arguments is the shortest.







