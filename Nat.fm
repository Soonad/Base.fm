// TODO: update

import Rec@1 open
import Bool@2 open

T Nat
| succ {pred : Nat}
| zero

pred : {n : Nat} -> Nat
  case<Nat> n
  | succ => pred
  | zero => zero
  : Nat

pred.example
  pred(succ(succ(zero)))

add :! {n : Nat, *m : Nat} -> Nat
  (case<Nat> n
  | succ => {m} succ(add(pred, m))
  | zero => {m} m
  : {m : Nat} -> Nat)(m)

// Recursive functions must be boxed (annotated with `:!`). They must also
// provide a "halt" case with `*`, which will be returned in the case the
// function runs out of "gas". That's because Formality is terminating. This is
// NOT a "native" "bounded recursion" feature, instead, it is desugared to
// `rec(TYPE, {r} => func[func <- r], halt)`. Notice that the `rec`, the
// function that repeatedly calls `func` as many times as needed, must be in
// scope. See `rec` below to see how Church nats can be used for that.
// Note: if the halt value isn't any of the function arguments, you can simply
// provide it after the end of the function by writting `* halt_value` there.
double :! {&n : Nat} -> Nat
  case<Nat> n
  | succ => succ(succ(double(pred)))
  | zero => zero
  : Nat

// Non-recursive functions that use recursive functions must also be boxed.
// They must unbox the recursive functions they use.
double.example :! Nat
  unbox double
  double(succ(zero))

// Converts a native U32 to a Nat
from_u32 :! {x : U32} -> Nat
  cpy x = x
  if |x == 0| then:
    zero
  else:
    succ(from_u32(|x - 1|))
  * zero

// Converts a Nat to a native U32
to_u32 :! {n : Nat} -> U32
  case<Nat> n
  | succ => |1 + to_u32(pred)|
  | zero => 0
  : U32
  * 0

// Converts a Rec to a Nat
from_rec : {r : Rec} -> !Nat
  (%r)(~{r}Nat, #{~r}succ, #zero)

main
: <succ(succ(zero)) == -add(succ(zero), succ(zero))>
  refl<succ(succ(zero))>
