import And
import Bool
import Empty
import Equal
import IBin
import IBits
import INat
import The
import Unit

T Nat
| zero
| succ(pred : Nat)

// Predecessor
pred(n : Nat) : Nat
  case n
  | zero => zero
  | succ => n.pred
  : Nat

// Addition
add(n : Nat, m : Nat) : Nat
  case n
  + m : Nat
  | zero => m
  | succ =>
    case m
    + n.pred : Nat
    | zero => succ(n.pred)
    | succ => succ(succ(add(n.pred, m.pred)))
    : Nat
  : Nat

// Doubles
double(n : Nat) : Nat
  case n
  | zero => zero
  | succ => succ(succ(double(n.pred)))
  : Nat

// Converts a native Num to a Nat
number_to_nat(x : Number) : Nat
  if x .==. 0:
    zero
  else:
    succ(number_to_nat(x .-. 1))

// Converts a Nat to a native Num
nat_to_number(n : Nat) : Number
  case n
  | zero => 0
  | succ => 1 .+. nat_to_number(n.pred)
  : Number

// Returns two copies of the same Nat
copy_nat(n : Nat) : [:Nat, Nat]
  case n
  | zero => [zero, zero]
  | succ => get [n0, n1] = copy_nat(n.pred); [succ(n0), succ(n1)]
  : [:Nat, Nat]

// Returns two proven equal copies of the same Nat
clone_nat(n : Nat) : [: Same(Nat, n), Same(Nat, n)]
  case n
  | zero => [[zero, refl(~Nat, ~zero)], [zero, refl(~Nat, ~zero)]]
  | succ =>
    get [n0_cpy, n1_cpy] = clone_nat(n.pred)
    get [n0_val, n0_eql] = n0_cpy
    get [n1_val, n1_eql] = n1_cpy
    let sn0_eql = cong(~Nat, ~Nat, ~n0_val, ~n.pred, ~succ, n0_eql)
    let sn1_eql = cong(~Nat, ~Nat, ~n1_val, ~n.pred, ~succ, n1_eql)
    [[succ(n0_val), sn0_eql], [succ(n1_val), sn1_eql]]
  : [: Same(Nat, n), Same(Nat, n)]

// Helper for the multiplication below.
mul.go(k : Nat, n : Nat, m : Nat) : Nat
  let f = mul.go
  case k
  + n : Nat
  + m : Nat
  + f : Nat -> Nat -> Nat -> Nat
  | zero =>
    case m
    | zero => zero
    | succ => f(n, zero, m.pred)
    : Nat
  | succ => succ(f(k.pred, succ(n), m))
  : Nat

// Tests if two nats are identical
nat_equals(n : Nat, m : Nat) : Bool
  case n
  + m : Nat
  | zero => case m
    | zero => true
    | succ => false
    : Bool
  | succ => case m
    | zero => false
    | succ => nat_equals(n.pred, m.pred)
    : Bool
  : Bool

// Multiplication
mul(n : Nat, m : Nat) : Nat
  mul.go(zero, n, m)

// Converts INat to Nat
inat_to_nat(n : INat) : !Nat
  use(n)(~(n) => Nat, #zero, #(~i) => succ)

// Converts IBin to Nat
ibin_to_nat(bin : IBin) : !Nat
  (use(bin))(~(x) => Nat, #zero, #(~i,a,b) => succ(a))

// Converts IBits to Nat
ibits_to_nat(bits : IBits) : !Nat
  (use(bits))(~(x) => Nat, #zero, #(~i,a) => succ(a), #(~i,a) => succ(a))

// ::::::::::::::
// :: Theorems ::
// ::::::::::::::

// Proof that `1 != 0`
succ_isnt_zero(~n : -Nat, e : Equal(Nat, succ(n), zero)) : Empty
  let subst = (n) =>
    case n
    | zero => Empty
    | succ => Unit
    : Type
  rewrite(~Nat, ~succ(n), ~zero, e, ~subst, unit)

// Proof that `0 != 1`
zero_isnt_succ(~n : -Nat, e : Equal(Nat, zero, succ(n))) : Empty
  succ_isnt_zero(~n, sym(~Nat, ~zero, ~succ(n), e))

// Proofs that `n == m` implies `succ(n) == succ(m)`
cong_succ(~n : Nat, ~m : Nat, e : Equal(Nat, n, m))
: Equal(Nat, succ(n), succ(m))
  cong(~Nat, ~Nat, ~n, ~m, ~succ, e)

// :::::::::::
// :: Tests ::
// :::::::::::

nat.test0 : The(Nat, 6n)
  the(~Nat, add(3n, 3n))

nat.test1 : The(Nat, 6n)
  the(~Nat, mul(2n, 3n))

nat.test2 : The(Number, 6)
  the(~Number, nat_to_number(6n))
