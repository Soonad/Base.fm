// Nat.fm
// ======
//
// Natural numbers.

import Bool
import Either
import Empty
import Equal
import Pair
import Sigma
import The
import Unit

// Definition
// ----------

T Nat
| zero
| succ(pred: Nat)

one : Nat
  succ(zero)

T Comparison
| less_than
| equal_to
| greater_than

// Functions
// ---------

// Predecessor
pred(n: Nat) : Nat
  case n
  | zero => zero
  | succ => n.pred

// Copies a Nat
copy_nat(n: Nat) : Pair(Nat, Nat)
  case n
  | zero => pair(__ zero, zero)
  | succ => case copy_nat(n.pred) as pred
    | pair => pair(__ succ(pred.fst), succ(pred.snd))

// Addition
add(n: Nat, m: Nat) : Nat
  case n
  + m : Nat
  | zero => m
  | succ => case m
    + n.pred : Nat
    | zero => succ(n.pred)
    | succ => succ(succ(add(n.pred, m.pred)))

// Left-hand addition
addl(n: Nat, m: Nat) : Nat
  case n
  + m : Nat
  | zero => m
  | succ => succ(addl(n.pred, m))

// Subtraction
sub(n: Nat, m: Nat) : Nat
  case m
  + n : Nat
  | zero => n
  | succ => case n
    | zero => zero
    | succ => sub(n.pred, m.pred)

// Multiplication by 2
double(n: Nat) : Nat
  case n
  | zero => zero
  | succ => succ(succ(double(n.pred)))

// Helper for the multiplication below
mul.go(k: Nat, n: Nat, m: Nat) : Nat
  let f = mul.go
  case k
  + n: Nat
  + m: Nat
  + f: Nat -> Nat -> Nat -> Nat
  | zero => case m
    | zero => zero
    | succ => f(n, zero, m.pred)
  | succ => succ(f(k.pred, succ(n), m))

// Multiplication
mul(n: Nat, m: Nat) : Nat
  mul.go(zero, n, m)

//Non-affine, left-hand multiplication
mull(n: Nat, m: Nat) : Nat
  case n
  | zero => zero
  | succ => addl(m, mull(n.pred, m))

// Comparison
nat_compare(n: Nat, m: Nat) : Comparison
  case n
  + m: Nat
  | zero => case m
    | zero => equal_to
    | succ => less_than
  | succ => case m
    | zero => greater_than
    | succ => nat_compare(n.pred, m.pred)

// Equality
nat_equal(n: Nat, m: Nat) : Bool
  case nat_compare(n, m) as cmp
  | less_than    => false
  | equal_to     => true
  | greater_than => false

// Theorems
// --------
// Proof that `succ(n) == succ(m)` implies `n == m` (injectivity)
succ_inj(a: Nat; b: Nat; e: succ(a) == succ(b)): a == b
  apply(____ pred; e)

// Proof that `n != m` implies `succ(n) != succ(m)` (contraposition of injectivity)
succ_inj_contra(a: Nat; b: Nat; neq: a != b): succ(a) != succ(b)
  (eq) => neq(succ_inj(a; b; eq))

// Proof that `1 != 0`
succ_isnt_zero(n : Nat;) : succ(n) != zero
  let P = (n: Nat) =>
    case n
    | zero => Empty
    | succ => Unit
  (e) => unit :: rewrite P(.) with e

// Proof that `0 != 1`
zero_isnt_succ(n: Nat;): zero != succ(n)
  let P = (n: Nat) =>
    case n
    | zero => Unit
    | succ => Empty
  (e) => unit :: rewrite P(.) with e

// Proof that `n == m` implies `succ(n) == succ(m)`
apply_succ(n: Nat; m; e: n == m) : succ(n) == succ(m)
  apply(_____ e)

// Decidability of equality
eq_dec(a: Nat, b: Nat): Or(a == b, a != b)
  case a
  + b : Nat
  | zero => case b
    | zero => lft(__ equal(__))
    | succ => rgt(__ zero_isnt_succ(_))
    : Or(zero == b, zero != b)
  | succ => case b
    | zero => rgt(__ succ_isnt_zero(_)) 
    | succ => case eq_dec(a.pred, b.pred) as dec
      | lft => lft(__ apply(____ succ; dec.value))
      | rgt => rgt(__ succ_inj_contra(__ dec.value))
      : Or(succ(a.pred) == succ(b.pred), succ(a.pred) != succ(b.pred))
    : Or(succ(a.pred) == b, succ(a.pred) != b)
  : Or(a == b, a != b)

addl_zero(n: Nat) : addl(n, zero) == n
  case n
  | zero => equal(__)
  | succ => apply(____ succ; addl_zero(n.pred))
  : addl(n, zero) == n

addl_succ(n: Nat, m: Nat) : succ(addl(n,m)) == addl(n,succ(m))
  case n
  + m : Nat
  | zero => equal(__)
  | succ => apply(____ succ; addl_succ(n.pred,m))
  : succ(addl(n,m)) == addl(n,succ(m))

addl_comm(n: Nat, m: Nat) : addl(n,m) == addl(m,n)
  case n
  + m : Nat
  | zero =>
    case m
    | zero => equal(__)
    | succ => apply(____ succ; addl_comm(zero,m.pred))
    : addl(zero,m) == addl(m,zero)
  | succ => 
    let e = apply(____ succ; addl_comm(n.pred,m))
    rewrite(___ addl_succ(m,n.pred), Equal(Nat,addl(succ(n.pred),m)); e)
  : addl(n,m) == addl(m,n)

add_comm(n: Nat, m: Nat) : add(n,m) == add(m,n)
  case n
  + m : Nat
  | zero =>
    case m
    | zero => equal(__)
    | succ => equal(__)
    : add(zero,m) == add(m,zero)
  | succ =>
    case m
    | zero => equal(__)
    | succ => apply(____ (x) => succ(succ(x)); add_comm(n.pred,m.pred))
    : add(succ(n.pred),m) == add(m,succ(n.pred))
  : add(n,m) == add(m,n)

addl_succ_succ(n: Nat, m: Nat) : succ(succ(addl(n,m))) == addl(succ(n),succ(m))
  case n
  + m : Nat
  | zero => equal(__)
  | succ => apply(____ succ; addl_succ_succ(n.pred,m))
  : succ(succ(addl(n,m))) == addl(succ(n),succ(m))

add_addl(n: Nat, m: Nat) : add(n,m) == addl(n,m)
  case n
  + m : Nat
  | zero =>
    case m
    | zero => equal(__)
    | succ => equal(__)
    : add(zero,m) == addl(zero,m)
  | succ =>
    case m
    | zero => 
      let P = (x) => Equal(Nat,x,addl(zero,succ(n.pred)))
      let e = rewrite(___ add_comm(zero,succ(n.pred)),P; equal(__))
      let addl_zn = addl_comm(zero,succ(n.pred))
      rewrite(___ addl_zn,Equal(Nat,add(succ(n.pred),zero)); e)
    | succ => 
      let e = apply(____ (x) => succ(succ(x)); add_addl(n.pred,m.pred))
      let addl_ss = addl_succ_succ(n.pred,m.pred)
      rewrite(___ addl_ss, Equal(Nat,succ(succ(add(n.pred,m.pred)))); e)
    : add(succ(n.pred),m) == addl(succ(n.pred),m)
  : add(n,m) == addl(n,m)

-- Associativity of the sum
addl_assoc(a: Nat, b: Nat, c: Nat) : addl(a,  addl(b,  c)) == addl(addl(a,  b),  c)
  case a
  + b : Nat
  + c : Nat
  | zero => equal(__)
  | succ => apply(____ succ; addl_assoc(a.pred, b, c))
  : addl(a,  addl(b,  c)) == addl(addl(a,  b),  c)

addl_left_swap(a: Nat, b: Nat, c: Nat) : addl(a,  addl(b,  c)) == addl(b,  addl(a,  c))
  let eq1 = addl_assoc(a, b, c)
  let eq2 = apply(____ (x) => addl(x, c); addl_comm(a, b))
  let eq3 = mirror(___ addl_assoc(b, a, c))
  chain(____ eq1, chain(____ eq2, eq3))

addl_right_swap(a: Nat, b: Nat, c: Nat) : addl(addl(a,  b),  c) == addl(addl(a,  c),  b)
  let eq1 = mirror(___ addl_assoc(a, b, c))
  let eq2 = apply(____ addl(a); addl_comm(b, c))
  let eq3 = addl_assoc(a, c, b)
  chain(____ eq1, chain(____ eq2, eq3))

addl_inner_swap(a: Nat, b: Nat, c: Nat, d: Nat) : addl(addl(a,  b),  addl(c,  d)) == addl(addl(a,  c),  addl(b,  d))
  let eq1 = mirror(___ addl_assoc(a, b, addl(c, d)))
  let eq2 = apply(____ addl(a); addl_left_swap(b, c, d))
  let eq3 = addl_assoc(a, c, addl(b, d))
  chain(____ eq1, chain(____ eq2, eq3))

mull_n_zero(n: Nat) : mull(n, zero) == zero
  case n
  | zero => equal(__)
  | succ => mull_n_zero(n.pred)
  : mull(n, zero) == zero

mull_n_one(n: Nat) : mull(n, one) == n
  case n
  | zero => equal(__)
  | succ => apply(____ succ; mull_n_one(n.pred))
  : mull(n, one) == n

mull_n_succ(n: Nat, m: Nat) : mull(n,  succ(m)) == addl(n,  mull(n,  m))
  case n
  | zero => equal(__)
  | succ =>
    let eq1 = apply(____ addl(succ(m)); mull_n_succ(n.pred, m))
    let eq2 = apply(____ succ; addl_left_swap(m, n.pred, mull(n.pred, m)))
    chain(____ eq1, eq2)
  : mull(n,  succ(m)) == addl(n,  mull(n,  m))

mull_comm(a: Nat, b: Nat) : mull(a, b) == mull(b, a)
  case a
  | zero => mirror(___ mull_n_zero(b))
  | succ =>
    let eq1 = apply(____ addl(b); mull_comm(a.pred, b))
    let eq2 = mirror(___ mull_n_succ(b, a.pred))
    chain(____ eq1, eq2)
  : mull(a, b) == mull(b, a)

mull_leftdist(a: Nat, b: Nat, c: Nat) : mull(a,  addl(b,  c)) == addl(mull(a,  b),  mull(a,  c))
  case a
  | zero => equal(__)
  | succ =>
    let eq1 = apply(____ addl(addl(b, c)); mull_leftdist(a.pred, b, c))
    let eq2 = addl_inner_swap(b, c, mull(a.pred, b), mull(a.pred, c))
    chain(____ eq1, eq2)
  : mull(a,  addl(b,  c)) == addl(mull(a,  b),  mull(a,  c))

mull_rightdist(a: Nat, b: Nat, c: Nat) : mull(addl(a,  b),  c) == addl(mull(a,  c),  mull(b,  c))
  let eq1 = mull_comm(addl(a, b), c)
  let eq2 = mull_leftdist(c, a, b)
  let eq3 = apply(____ addl(mull(c, a)); mull_comm(c, b))
  let eq4 = apply(____ (x) => addl(x, mull(b, c)); mull_comm(c, a))
  chain(____ eq1, chain(____ eq2, chain(____ eq3, eq4)))

mull_assoc(a: Nat, b: Nat, c: Nat) : mull(a,  mull(b,  c)) == mull(mull(a,  b),  c)
  case a
  | zero => equal(__)
  | succ =>
    let eq1 = apply(____ addl(mull(b, c)); mull_assoc(a.pred, b, c))
    let eq2 = mirror(___ mull_rightdist(b, mull(a.pred, b), c))
    chain(____ eq1, eq2)
  : mull(a,  mull(b,  c)) == mull(mull(a,  b),  c)

mull_left_swap(a: Nat, b: Nat, c: Nat) : mull(a,  mull(b,  c)) == mull(b,  mull(a,  c))
  let eq1 = mull_assoc(a, b, c)
  let eq2 = apply(____ (x) => mull(x, c); mull_comm(a, b))
  let eq3 = mirror(___ mull_assoc(b, a, c))
  chain(____ eq1, chain(____ eq2, eq3))

mull_inner_swap(a: Nat, b: Nat, c: Nat, d: Nat) : mull(mull(a,  b),  mull(c,  d)) == mull(mull(a,  c),  mull(b,  d))
  let eq1 = mirror(___ mull_assoc(a, b, mull(c, d)))
  let eq2 = apply(____ mull(a); mull_left_swap(b, c, d))
  let eq3 = mull_assoc(a, c, mull(b, d))
  chain(____ eq1, chain(____ eq2, eq3))

-- Neutral elements
addl_uniq_neutral(a: Nat, b: Nat, or: Or(addl(a, b) == a, addl(b, a) == a)) : b == zero
  case a
  + or : Or(addl(a, b) == a, addl(b, a) == a)
  | zero => case or
    | lft => or.value
    | rgt => chain(____ mirror(___ addl_zero(b)), or.value)
    : b == zero
  | succ => case or
    | lft => addl_uniq_neutral(a.pred, b, lft(__ succ_inj(addl(a.pred, b); a.pred; or.value)))
    | rgt => addl_uniq_neutral(a.pred, b, rgt(__ succ_inj(addl(b, a.pred); a.pred; chain(____ addl_succ(b, a.pred), or.value))))
    : b == zero
  : b == zero

addl_no_inverse(a: Nat, b: Nat, eq: addl(a, b) == zero) : And(a == zero, b == zero)
  case a
  + eq : addl(a, b) == zero
  | zero => case b
    + eq : (addl(zero, b) == zero)
    | zero => pair(__ equal(__), equal(__))
    | succ => absurd(succ_isnt_zero(b.pred; eq) _)
    : And(zero == zero, b == zero)
  | succ => absurd(succ_isnt_zero(addl(a.pred, b); eq) _)
  : And(a == zero, b == zero)

when_addl_equals_succ(a: Nat, b: Nat, c: Nat, eq: addl(a, b) == succ(c)) : Sigma(Nat, (x : Nat) => Or(And(a == succ(x), addl(x, b) == c), And(b == succ(x), addl(a, x) == c)))
  let P = (a: Nat, b: Nat, c: Nat, x: Nat) => Or(And(a == succ(x), addl(x, b) == c), And(b == succ(x), addl(a, x) == c))
  case a
  + eq : addl(a, b) == succ(c)
  | zero => case b
    + eq : addl(zero, b) == succ(c)
    | zero => absurd(zero_isnt_succ(_ eq) _)
    | succ => sigma(Nat; P(zero, succ(b.pred), c); b.pred, rgt(__ pair(__ equal(__), succ_inj(b.pred; c; eq))))
    : Sigma(Nat, P(zero, b, c))
  | succ => case b
    + eq : addl(succ(a.pred), b) == succ(c)
    | zero => sigma(Nat; P(succ(a.pred), zero, c); a.pred, lft(__ pair(__ equal(__), succ_inj(addl(a.pred, zero); c; eq))))
    | succ => case c
      + eq : addl(succ(a.pred), succ(b.pred)) == succ(c)
      | zero => absurd(succ_isnt_zero(addl(b.pred, a.pred); chain(____ addl_comm(succ(b.pred), a.pred), succ_inj(addl(a.pred, succ(b.pred)); zero; eq))) _)
      | succ => sigma(Nat; P(succ(a.pred), succ(b.pred), succ(c.pred)); a.pred, lft(__ pair(__ equal(__), succ_inj(addl(a.pred, succ(b.pred)); succ(c.pred); eq))))
      : Sigma(Nat, P(succ(a.pred), succ(b.pred), c))
    : Sigma(Nat, P(succ(a.pred), b, c))
  : Sigma(Nat, P(a, b, c))

when_addl_equals_one(a: Nat, b: Nat, eq: addl(a, b) == one) : Or(And(a == one, b == zero), And(b == one, a == zero))
  let P = (a: Nat, b: Nat, c: Nat) => Or(And(a == one, b == zero), And(b == one, c == zero))
  case when_addl_equals_succ(a, b, zero, eq) as x
  | sigma => case x.fst
    + x.snd : Or(And(Equal(Nat, a, succ(x.fst)), Equal(Nat, addl(x.fst, b), zero)), And(Equal(Nat, b, succ(x.fst)), Equal(Nat, addl(a, x.fst), zero)))
    | zero => rewrite(___ addl_zero(a), P(a, b); x.snd)
    | succ => case x.snd
      | lft => absurd(succ_isnt_zero(addl(x.fst.pred, b); pair_snd(__ x.snd.value)) _)
      | rgt => absurd(succ_isnt_zero(addl(a, x.fst.pred); chain(____ addl_succ(a, x.fst.pred), pair_snd(__ x.snd.value))) _)
      : P(a, b, a)
    : P(a, b, a)
  : P(a, b, a)

T LTE(a: Nat, b: Nat)
  | lte.zero(a: Nat) : LTE(zero, a)
  | lte.succ(a: Nat, b: Nat, lte: LTE(a, b)) : LTE(succ(a), succ(b))

succ_not_lte_zero(a: Nat; pf: LTE(succ(a), zero)) : Empty
  let motive    = (x, y, _)         => (x == succ(a)) -> (y == zero) -> Empty
  let case_zero = (_, eq1, _)       => absurd(zero_isnt_succ(_ eq1) _)
  let case_succ = (_, _, _, _, eq2) => absurd(succ_isnt_zero(_ eq2) _)
  (use(pf)(motive; case_zero, case_succ))(equal(__), equal(__))

lte.pred(a: Nat; b: Nat; pf: LTE(succ(a), succ(b))) : LTE(a, b)
  let motive    = (x, y, _)                 => (x == succ(a)) -> (y == succ(b)) -> LTE(a, b)
  let case_zero = (_, eq1, _)               => absurd(zero_isnt_succ(_ eq1) _)
  let case_succ = (x, y, pf.pred, eq1, eq2) =>
    (pf.pred :: rewrite LTE(x,.) with succ_inj(__ eq2)) :: rewrite LTE(.,b) with succ_inj(__ eq1)
  (use(pf)(motive; case_zero, case_succ))(equal(__), equal(__))

// An alternative definition of `a <= b` which is really useful is `exists x : Nat, a + x = b` therefore we can write the following functions:
lte_add_get(a: Nat, b: Nat, pf: LTE(a, b)) : Sigma(Nat, (x: Nat) => addl(a, x) == b)
  let P = (a: Nat, b: Nat, x: Nat) => addl(a, x) == b
  case a
  + pf : LTE(a, b)
  | zero => sigma(Nat; P(zero, b); b, equal(__))
  | succ => case b
    + pf : LTE(succ(a.pred), b)
    | zero => absurd(succ_not_lte_zero(_ pf), _)
    | succ => case lte_add_get(a.pred, b.pred, lte.pred(__ pf)) as pair
      | sigma => sigma(Nat; P(succ(a.pred), succ(b.pred)); pair.fst, apply(____ succ; pair.snd))
      : Sigma(Nat, P(succ(a.pred), succ(b.pred)))
    : Sigma(Nat, P(succ(a.pred), b))
  : Sigma(Nat, P(a, b))

lte_add(a: Nat, b: Nat, x: Nat, eq: addl(a, x) == b) : LTE(a, b)
  case a
  + eq : addl(a, x) == b
  | zero => lte.zero(b)
  | succ => case b
    + eq : addl(succ(a.pred), x) == b
    | zero => absurd(succ_isnt_zero(addl(a.pred, x); eq) _)
    | succ => lte.succ(a.pred, b.pred, lte_add(a.pred, b.pred, x, succ_inj(addl(a.pred, x); _ eq)))
    : LTE(succ(a.pred), b)
  : LTE(a, b)

// Less-than-or-equal properties
lte_refl(a: Nat, b: Nat, eq: a == b) : LTE(a, b)
  case a
  + eq : a == b
  | zero => lte.zero(b)
  | succ => case b
    + eq : succ(a.pred) == b
    | zero => absurd(succ_isnt_zero(_ eq) _)
    | succ => lte.succ(a.pred, b.pred, lte_refl(a.pred, b.pred, succ_inj(__ eq)))
    : LTE(succ(a.pred), b)
  : LTE(a, b)

lte_same(a: Nat) : LTE(a, a)
  lte_refl(a, a, equal(__))

lte_bottom(a: Nat, pf: LTE(a, zero)) : a == zero
  case a
  + pf: LTE(a, zero)
  | zero => equal(__)
  | succ => absurd(succ_not_lte_zero(_ pf), _)
  : a == zero

lte_trans(a: Nat, b: Nat, c: Nat, ab: LTE(a, b), bc: LTE(b, c)) : LTE(a, c)
  case a
  + ab : LTE(a, b)
  + bc : LTE(b, c)
  | zero => lte.zero(c)
  | succ => case b
    + ab : LTE(succ(a.pred), b)
    + bc : LTE(b, c)
    | zero => absurd(succ_not_lte_zero(_ ab) _)
    | succ => case c
      + ab : LTE(succ(a.pred), succ(b.pred))
      + bc : LTE(succ(b.pred), c)
      | zero => absurd(succ_not_lte_zero(_ bc) _)
      | succ => lte.succ(a.pred, c.pred, lte_trans(a.pred, b.pred, c.pred, lte.pred(__ ab), lte.pred(__ bc)))
      : LTE(succ(a.pred), c)
    : LTE(succ(a.pred), c)
  : LTE(a, c)

lte_antisym(a: Nat, b: Nat, ab: LTE(a, b), ba: LTE(b, a)) : a == b
  case a
  + ab: LTE(a, b)
  + ba: LTE(b, a)
  | zero => mirror(___ lte_bottom(b, ba))
  | succ => case b
    + ab: LTE(succ(a.pred), b)
    + ba: LTE(b, succ(a.pred))
    | zero => absurd(succ_not_lte_zero(_ ab) _)
    | succ => apply(____ succ; lte_antisym(a.pred, b.pred, lte.pred(__ ab), lte.pred(__ ba)))
    : succ(a.pred) == b
  : a == b

lte_total(a: Nat, b: Nat) : Or(LTE(a, b), LTE(b, a))
  case a
  | zero => lft(__ lte.zero(b))
  | succ => 
    case b
    | zero => rgt(__ lte.zero(succ(a.pred)))
    | succ => case lte_total(a.pred, b.pred) as or
      | lft => lft(__ lte.succ(a.pred, b.pred, or.value))
      | rgt => rgt(__ lte.succ(b.pred, a.pred, or.value))
      : Or(LTE(succ(a.pred), succ(b.pred)), LTE(succ(b.pred), succ(a.pred))) 
    : Or(LTE(succ(a.pred), b), LTE(b, succ(a.pred))) 
  : Or(LTE(a, b), LTE(b, a))

lte_dec(a: Nat, b: Nat) : Or(LTE(a, b), Not(LTE(a, b)))
  case a
  | zero => lft(__ lte.zero(b))
  | succ => case b
    | zero => rgt(__ succ_not_lte_zero(_))
    | succ => case lte_dec(a.pred, b.pred) as or
      | lft => lft(__ lte.succ(a.pred, b.pred, or.value))
      | rgt => rgt(__ (pf: LTE(succ(a.pred), succ(b.pred))) => or.value(lte.pred(__ pf)))
      : Or(LTE(succ(a.pred), succ(b.pred)), Not(LTE(succ(a.pred), succ(b.pred))))
    : Or(LTE(succ(a.pred), b), Not(LTE(succ(a.pred), b)))
  : Or(LTE(a, b), Not(LTE(a, b)))

lte_trichotomy(a: Nat, b: Nat) : Or(a == b, Or(LTE(succ(a), b), LTE(succ(b), a)))
  case a
  | zero => case b
    | zero => lft(__ equal(__))
    | succ => rgt(__ lft(__ lte.succ(zero, b.pred, lte.zero(b.pred))))
    : Or(zero == b, Or(LTE(succ(zero), b), LTE(succ(b), zero)))
  | succ => case b
    | zero => rgt(__ rgt(__ lte.succ(zero, a.pred, lte.zero(a.pred))))
    | succ => case lte_trichotomy(a.pred, b.pred) as or
      | lft => lft(__ apply(____ succ; or.value))
      | rgt => case or.value as or
        | lft => rgt(__ lft(__ lte.succ(succ(a.pred), b.pred, or.value)))
        | rgt => rgt(__ rgt(__ lte.succ(succ(b.pred), a.pred, or.value)))
        : Or(succ(a.pred) == succ(b.pred), Or(LTE(succ(succ(a.pred)), succ(b.pred)), LTE(succ(succ(b.pred)), succ(a.pred))))
      : Or(succ(a.pred) == succ(b.pred), Or(LTE(succ(succ(a.pred)), succ(b.pred)), LTE(succ(succ(b.pred)), succ(a.pred))))
    : Or(succ(a.pred) == b, Or(LTE(succ(succ(a.pred)), b), LTE(succ(b), succ(a.pred))))
  : Or(a == b, Or(LTE(succ(a), b), LTE(succ(b), a)))

// Tests
// -----

nat.test0: The(Nat, 6n)
  the(_ add(3n, 3n))

nat.test1: The(Nat, 6n)
  the(_ mul(2n, 3n))
