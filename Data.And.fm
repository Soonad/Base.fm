// A value (proof) of type `And(A,B)` contains *both*:
// - a value (proof) of the first type, `A`, *and*...
// - a value (proof) of the second type, `B`
T And {A : Type, B: Type}
| both { left : A, right : B }

// ::::::::::::::
// :: Theorems ::
// ::::::::::::::

// (p && q) <-> (q && p)
And.commutation : {~A : Type, ~B : Type , case c : And(A,B)} -> And(B,A)
| both => both(~B,~A,c.right,c.left)

// p -> (p && p)
And.tautology : {~A : Type, a : !A} -> And(!A,!A)
  dup a = a
  both(~!A,~!A, #a, #a)

// If and only if: p <-> q
Iff : {A : Type, B : Type} -> Type
  And(A -> B, B -> A)

// (p && q) && r <-> p && (q && r)
And.association : {~A : Type, ~B : Type, ~C : Type} -> Iff(And(A,And(B,C)), And(And(A,B), C))
  let Lft = And(A,And(B,C)) -> And(And(A,B), C)
  let Rgt = And(And(A,B), C) -> And(A,And(B,C))
  let lft = {c} And.association1(~A,~B,~C,c)
  let rgt = {c} And.association2(~A,~B,~C,c)
  both(~Lft, ~Rgt, lft, rgt)

And.association1 : {~A : Type, ~B : Type, ~C : Type, case x : And(A,And(B,C))} -> And(And(A,B), C)
| both =>
  case/And x.right as xr
  | both => both(~And(A,B), ~C, both(~A,~B, x.left, xr.left), xr.right)
  : And(And(A,B),C)

And.association2 : {~A : Type, ~B : Type, ~C : Type, case x : And(And(A,B), C)} -> And(A,And(B,C))
| both =>
  case/And x.left as xl
  | both => both(~A, ~And(B,C), xl.left, both(~B,~C, xl.right, x.right))
  : And(A,And(B,C))
