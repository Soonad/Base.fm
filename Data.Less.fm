import Data.Empty open
import Data.Nat open
import Data.Unit open
import Induction.Nat open
import Induction.Nat.Unstep open

// a < b
T Less (a : Nat, b : Nat)
| less_succ {~a : Nat, ~b : Nat, l : Less(a, b)} (succ(a), succ(b))  // ∀a b. a < b -> a+1 < b+1
| less_zero {~b : Nat}                           (zero   , succ(b))  // ∀b  . 0 < b+1

// `2 < 4`
less.example : Less(0n2, 0n4)
  less_succ(~0n1, ~0n3,
  less_succ(~0n0, ~0n2,
  less_zero(~0n1)))

T Bound (n : Nat, i : Ind)
| bound_succ {~n : Nat, ~i : Ind, k : Bound(n, i)} (succ(n), step(i))
| bound_zero {~i : Ind}                            (zero   , step(i))

absurd_bound : {n : Nat, bound : Bound(n, base)} -> Empty
  case/Bound bound
  | bound_succ => unit
  | bound_zero => unit
  : <ind(i, ~{i}Type, #{~r,i}Unit, #Empty)>

// ∀ n . n < n+1
!less_than_succ*N : !{n : Nat, bound : Bound(n, N)} -> Less(n, succ(n))
  (case/Bound bound
  | bound_succ => {e}
    let r0 = cong_unstep(~i, ~N, ~e)
    let r1 = less_than_succ(n, k :: rewrite x in Bound(n, x) with r0)
    let r2 = less_succ(~n, ~succ(n), r1)
    r2
  | bound_zero => {e} less_zero(~zero)
  : {e : i == step(N)} -> Less(n, succ(n)))(refl(~step(N)))
  * absurd(absurd_bound(n, bound), ~Less(n, succ(n)))
