version Bool 9
import Bool open
import BinaryOperation open
import Magma as M


test : Type
  {A:Type,f:A -> A -> A} -> M/Bin/Associative(A,f)

T Semigroup<A : Type>
| mkSemigroup { f : A -> A -> A, associative : Associative(A,f)}

toMagma : {~A : Type, m : Semigroup(A)} -> M/Magma(A)
  case<Semigroup> m | mkSemigroup => M/mkMagma<A>(f) : M/Magma(A)

semigroupBoolAnd : Semigroup(Bool)
  let andIsAssociative = {a : Bool, b : Bool, c : Bool}
    let theo = {x : Bool, y : Bool, z : Bool} and(and(x,y),z) == and(x,and(y,z))
    ( case<Bool> a
    | true => {b, c} (case<Bool> b
      | true  => {c} case<Bool> c
        | true => refl<true> | false => refl<false> : theo(true, true, self)
      | false  => {c} case<Bool> c
        | true => refl<false> | false => refl<false> : theo(true,false,self)
      : {c : Bool} -> theo(true, self, c))(c)
    | false => {b, c} (case<Bool> b
      | true  => {c} case<Bool> c
        | true => refl<false> | false => refl<false> : theo(false, true, self)
      | false  => {c} case<Bool> c
        | true => refl<false> | false => refl<false> : theo(false,false,self)
      : {c : Bool} -> theo(false, self, c))(c)
    : {b : Bool, c : Bool} -> theo(self, b, c))(b,c)
  mkSemigroup<Bool>(and,andIsAssociative)

semigroupBoolOr : Semigroup(Bool)
  let orIsAssociative = {a : Bool, b : Bool, c : Bool}
    let theo = {x : Bool, y : Bool, z : Bool} or(or(x,y),z) == or(x,or(y,z))
    ( case<Bool> a
    | true => {b, c} (case<Bool> b
      | true  => {c} case<Bool> c
        | true => refl<true> | false => refl<true> : theo(true, true, self)
      | false  => {c} case<Bool> c
        | true => refl<true> | false => refl<true> : theo(true,false,self)
      : {c : Bool} -> theo(true, self, c))(c)
    | false => {b, c} (case<Bool> b
      | true  => {c} case<Bool> c
        | true => refl<true> | false => refl<true> : theo(false, true, self)
      | false  => {c} case<Bool> c
        | true => refl<true> | false => refl<false> : theo(false,false,self)
      : {c : Bool} -> theo(false, self, c))(c)
    : {b : Bool, c : Bool} -> theo(self, b, c))(b,c)
  mkSemigroup<Bool>(or,orIsAssociative)

T InverseSemigroup<A : Type>
| mkInverseSemigroup 
  { f : A -> A -> A
  , inverseSemigroup1 : Associative(A,f)
  , inverseSemigroup2 : {x : A} -> [y : A,[:x == f(x,f(y,x)),y == f(y,f(x,y))]]
  }

