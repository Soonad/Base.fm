import Induction.Nat

T Nat
| succ {pred : Nat}
| zero

// ::::::::::::::::::::::
// :: Simple functions ::
// ::::::::::::::::::::::

// Predecessor
pred : {case n : Nat} -> Nat
| succ => n.pred
| zero => zero

// Addition
#add*N : !{case n : Nat, halt m : Nat} -> Nat
| succ => succ(add(n.pred, m))
| zero => m

// Doubles
#double*N : !{case halt n : Nat} -> Nat
| succ => succ(succ(double(n.pred)))
| zero => zero

// Converts a native Word to a Nat
#word_to_nat*N : !{x : Word} -> Nat
  if x .= 0:
    zero
  else:
    succ(word_to_nat(x - 1))
  halt:
    zero

// Converts a Nat to a native Word
#nat_to_word*N : !{case n : Nat} -> Word
| succ => 1 + nat_to_word(n.pred)
| zero => 0
halt: 0

// Converts a Ind to a Nat
nat : {r : Ind} -> !Nat
  dup func = (%r)(~{r}Nat, #{~r}succ)
  # func(zero)

// Returns two copies of the same Nat
#copy_nat*N : !{case n : Nat} -> [:Nat, Nat]
| succ =>
  get [n0, n1] = copy_nat(n.pred)
  [succ(n0), succ(n1)]
| zero => 
  [zero, zero]
halt: [zero, zero]

// Multiplication by a static `n`. This requires a small amount of gas (`N`
// must be >= `m`), but `n` must be static w.r.t `m`.
#muln*N : {n : !Nat} -> !{m : Nat} -> Nat
  case/Nat m
  | succ => <#<(add*)>(n)>(muln(pred))
  | zero => zero
  : Nat
halt: zero

// Helper for the multiplication below.
#mul.go*N : ! {case add : Nat, n : Nat, m : Nat} -> Nat
| succ => succ(mul.go(add.pred, succ(n), m))
| zero =>
  case/Nat m
  | succ => mul.go(n, zero, pred)
  | zero => zero
  : Nat
halt: zero

// Multiplication. This allows `n` and `m` to be dynamic relative to
// each-other, but requires more gas (`N` must be >= `n * m`).
#mul : {N : Ind} -> ! {n : Nat, m : Nat} -> Nat
  <mul.go*N>(zero, n, m)

// ::::::::::::::
// :: Examples ::
// ::::::::::::::

#add.example : !Nat
  <add*>(0n3, 0n2)

#double.example : !Nat
  <double*>(succ(zero))

#muln.example : !Word
  <nat_to_word*>(<muln*(#0n3)>(0n4))

#mul.example : !Word
  <nat_to_word*>(<mul*>(0n3, 0n4))
