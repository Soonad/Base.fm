import Induction.Nat

T Nat
| succ {pred : Nat}
| zero

// ::::::::::::::::::::::
// :: Simple functions ::
// ::::::::::::::::::::::

pred : {case n : Nat} -> Nat
| succ => n.pred
| zero => zero

!add*N : !{case n : Nat, *m : Nat} -> Nat
| succ => succ(add(n.pred, m))
| zero => m

!double*N : !{case *n : Nat} -> Nat
| succ => succ(succ(double(n.pred)))
| zero => zero

// Non-recursive functions that use recursive functions must also be boxed.
// They must unbox the recursive functions they use.
!double.example : !Nat
  <double*256>(succ(zero))

// Converts a native Word to a Nat
!from_word*N : !{x : Word} -> Nat
  if x .= 0:
    zero
  else:
    succ(from_word(x - 1))
  * zero

// Converts a Nat to a native Word
!to_word*N : !{case n : Nat} -> Word
| succ => 1 + to_word(n.pred)
| zero => 0
* 0

// Converts a Ind to a Nat
from_ind : {r : Ind} -> !Nat
  dup func = (%r)(~{r}Nat, #{~r}succ)
  # func(zero)
