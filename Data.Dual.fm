import Algebra.Operation
import Algebra.Semigroup
import Algebra.Monoid
import Data.Function

// a dual function flips the arguments of a binary operation
dual : {A : Type, f : Op2(A)} -> Op2(A)
  {x,y} f(y,x)

//dual.associative :
  //{ ~A : Type
  //, case ~s : Setoid(A)
  //, ~f : Op2(A)
  //, a : Associative(A,s,f)
  //} -> Associative(A,s,dual(A,f))
//| setoid => case/Equivalence s.equivalence as se
  //| equivalence => {x,y,z} se.symmetric(~(f(f(z,y),x)),~(f(z,f(y,x))),~a(z,y,x))
  //: {x : A, y : A, z : A} -> s.R(f(z,f(y,x)), f(f(z,y),x))

dual.identity :
  { ~A : Type
  , ~s : Setoid(A)
  , ~f : Op2(A)
  , ~e : A
  , identity : Identity(A,s,f,e)
  } -> Identity(A,s,dual(A,f),e)
  let L = LeftIdentity(A,s,f,e)
  let R = RightIdentity(A,s,f,e)
  case/And identity as i
  | both => both(~R,~L,i.right,i.left)
  : Identity(A,s,dual(A,f),e)

// Dual semigroup
//dual.semigroup :
  //{ ~A : Type
  //, ~s : Setoid(A)
  //, case m : Semigroup(A,s)
  //} -> Semigroup(A,s)
//| semigroup =>
  //let associative = dual.associative(~A,~s,~m.f,m.associative)
  //semigroup(~A,~s,dual(A,m.f),associative)

// Dual monoid
//dual.monoid : {~A : Type, ~s : Setoid(A), case m : Monoid(A,s)} -> Monoid(A,s)
//| monoid =>
  //let associative = dual.associative(~A,~s,~m.f,m.associative)
  //let identity = dual.identity(~A,~s,~m.f,~m.e,m.identity)
  //monoid(~A,~s,dual(A,m.f),m.e,associative,identity)
