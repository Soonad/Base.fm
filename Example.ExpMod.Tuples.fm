// This file was ported from the old Formality-Core.
// TODO: add types, move Cat to its own file, update comments

Tup.rotate_right {n}
  let editable_one  = {EDIT0} EDIT0({EDIT1, k} EDIT1({T} T(k)))
  let editable_succ = {ed} {EDIT0} EDIT0(ed({P0, EDIT1, x} P0({P1} EDIT1({T} P1({k} T(k, x))))))
  let editable_pred = {ed} {EDIT0} EDIT0(ed({P0, EDIT1} P0({P1} EDIT1({T} P1({k, a} T(k))), {x}x)))
  let to_tup_rotate = {ed} ed({P0, tup, T} tup(P0({t} t(T))))
  dup fold = n(#editable_succ)
  # to_tup_rotate(editable_pred(fold(editable_one)))

// Teturns a tuple with all numbers from N-1 to 0:
Tup.rev_range {n}
  dup fold = n(#{state}
    get [index, tuple] = state
    cpy index          = index
    [index + 1, {T} tuple(T(index))])
  # snd(fold([0, {T} T]))

// Given a `tuple_N`, returns its first element.
Tup.last {n}
  let editable_one  = {EDIT} EDIT({x}x)
  let editable_succ = {ed, edit} ed({get_last} edit({x} get_last))
  let editable_pred = {ed, edit} ed({get_last} edit(get_last({x} x)))
  let to_tup_last   = {ed, T} T(ed({x}x))
  dup fold = n(#editable_succ)
  # to_tup_last(editable_pred(fold(editable_one)))

Tup.new {a, b}
  {tup} tup(a, b)

Tup.fst {tup}
  tup({a, b} a)

Tup.snd {tup}
  tup({a, b}b)

Tup.pushfront
  {a, tup} {t} tup(t(a))

Tup.pushback
  {a, tup} {t} tup(t, a)

Tup.popfront
  {tup} {t} tup({x} t)

Tup.empty {t} t

Tup.concat {tup1, tup2} {t}
  tup2(tup1(t))

Cat : Type
  {~P : Type, csucc : ! P -> P} -> ! {czero : P} -> P

step : {r : Cat} -> Cat
  {~P, csucc}
  dup csucc = csucc
  dup cfunc = r(~P, #csucc)
  # {czero} csucc(cfunc(czero))

base : Cat
  {~P, csucc}
  dup csucc = csucc
  # {czero} czero

twice : {n : Cat} -> Cat
  {~P, csucc}
  dup csucc = csucc
  n(~P, #{i} csucc(csucc(i)))

cexp {a, x}
  x(a)

