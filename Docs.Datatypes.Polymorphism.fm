import Base@0

// Polymorphism
// ------------

// Polymorphic datatypes allow us to create multiple instances of the same datatype with different contained types.

T Pair {A : Type, B : Type}
| pair {x : A, y : B}

polymorphism.example_0 : Word
  let a = pair(~Bool, ~Word, true, 7)

  case/Pair a
  | pair => a.y
  : Word

// The {A : Type, B : Type} after the datatype declares two polymorphic variables, A and B, allowing us to create different types of pair, such as a pair of Bool, or a pair of Word, without needing to duplicate the definition of Pair. Each polymorphic variable adds an implicit, erased argument to each constructor, so, instead of pair(true, 7), you need to write pair(~Bool, ~Word, true, 7). In a future, this verbosity will be prevented with implicit arguments. For now, you can amend it with a let:

polymorphism.example_1 : [:Pair(Bool, Bool), Pair(Bool, Bool)]
  let pairbb = pair(~Bool, ~Bool)

  let a = pairbb(true, false)
  let b = pairbb(false, true)
  [a, b]

// By combining polymorphism with recursive types, we can create the popular List type:

T List {T : Type}
| cons {head : T, tail : List(T)}
| nil

// {- Returns all but the first element -}
tail : {~T : Type, case list : List(T)} -> List(T)
| cons => list.tail
| nil  => nil(~T)

polymorphism.example_2a : List(Word)
  tail(~Word, cons(~Word, 1, cons(~Word, 2, cons(~Word, 3, nil(~Word)))))

// Since List is so common, there is a built-in syntax-sugar for it, the dollar sign:

polymorphism.example_2b : List(Word)
  tail(~Word, Word$[1, 2, 3])


