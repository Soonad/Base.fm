import Function open
import Equality open
import Functor as F
import Monad as M

T Maybe<A : Type>
| just {some : A}
| none

functor : F/Functor(Maybe)
  let map = {~A:Type, ~B:Type, f:A -> B, ma:Maybe(A)}
    case<Maybe> ma | just => just<B>(f(some)) | none => none<B> : Maybe(B)
  let map.identity = {~A:Type, ma:Maybe(A)}
    case<Maybe> ma | just => refl<just<A>(some)> | none => refl<none>
    : map<A,A>(id<A>,self) == self
  let map.composition =
    {~A:Type, ~B:Type, ~C:Type, g:B -> C, f:A -> B, ma:Maybe(A)}
      case<Maybe> ma | just => refl<just<C>(g(f(some)))> | none => refl<none>
      : map<A,C>({x:A} g(f(x)),self) == map<B,C>(g,map<A,B>(f,self))
   F/mkFunctor<Maybe>(map,map.identity,map.composition)

monad : M/Monad(Maybe)
  let return = {~A:Type, x:A} just(~A,x)
  let bind = {~A:Type, ~B:Type, ma:Maybe(A), f : A -> Maybe(B)}
     case<Maybe> ma | just => f(some) | none => none<B> : Maybe(B)
  let monad.identity1 = {~A:Type, ~B:Type, x:A, f:A -> Maybe(B)}
    case<Maybe> f(x) | just => refl<just<B>(some)> | none => refl<none>
    : self == self
  let monad.identity2 = {~A:Type, m:Maybe(A)}
    case<Maybe> m | just => refl<just<A>(some)> | none => refl<none>
    : bind<A,A>(self,return<A>) == self
  let monad.assoc =
    {~A:Type, ~B:Type, ~C:Type , m:Maybe(A), f:A -> Maybe(B), g:B -> Maybe(C)}
    case<Maybe> m
    | just => case<Maybe> f(some)
      | just => case<Maybe> g(some)
        | just => refl<just<C>(some)>
        | none => refl<none>
        : self == self
      | none => refl<none>
      : bind<B,C>(self, g) == bind<B,C>(self, g)
    | none => refl<none>
    : bind<B,C>(bind<A,B>(self,f),g) == bind<A,C>(self,{x:A} bind<B,C>(f(x),g))
  M/mkMonad<Maybe>(return,bind,monad.identity1,monad.identity2,monad.assoc)

