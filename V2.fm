import Ind open
import Nat open
import List open

V2 : Type
  [:Word, Word]

// Approximates pi
//def V2.ex:
//  let srad = 1200
//  let form = (V2.circle ~5000 #srad)
//  let hits = {pos num} |1 + num|
//  dup circ = (form #hits)
//  # ||(circ [256,256] 0) * 1000000| / srad|


V2.add : {a : V2, b : V2} -> V2
  get [ax,ay] = a
  get [bx,by] = b
  [ax + bx, ay + by]

V2.scale: {a : V2, s : Word} -> V2
  get [ax,ay] = a
  [ax * s, ay * s]

V2.neg: {a : V2} -> V2
  get [ax,ay] = a
  [0 - ax, 0 - ay]

V2.cpy: {a : V2} -> [:V2, V2]
  get [ax,ay] = a
  cpy ax      = ax
  cpy ay      = ay
  [[ax,ay], [ax,ay]]

Num.dif: {a : Word, b : Word} -> Word
  cpy a = a
  cpy b = b
  if a > b: a - b
  else: b - a

V2.sqr_dist: {a : V2, b : V2} -> Word
  get [ax,ay] = a
  get [bx,by] = b
  cpy dx = Num.dif(ax, bx) ^ 2
  cpy dy = Num.dif(ay, by) ^ 2
  dx + dy

Num.sqrt: {n : Word} -> Word
  n ** 2147483648

V2.dist: {a : V2, b : V2} -> Word
  Num.sqrt(V2.sqr_dist(a, b))

V2.flat_dist: {a : V2, b : V2} -> Word
  get [ax,ay] = a
  get [bx,by] = b
  Num.dif(ax, bx) + Num.dif(ay, by)

!V2.line*n: !{len : Word, pos : V2, dxy : V2} -> List(V2) -> List(V2)
    get [ax,ay] = pos
    get [dx,dy] = dxy
    cpy len = len
    cpy ax  = ax
    cpy ay  = ay
    cpy dx  = dx
    cpy dy  = dy
    (if len === 0:  {xs : List(V2)} => xs
      else:         {xs : List(V2)} => cons<V2>([ax,ay], V2.line(len - 1, [ax + dx,ay + dy], [dx,dy], xs)))
  * {xs} => xs

!V2.area_aux*mlen : {size : !V2, cond : !{cen : V2, siz : V2, pos : V2} -> Word} -> !{pos : V2, idx : Word} -> List(V2)
    get [cx,cy] = pos
    get [sx,sy] = size
    cpy sx = sx
    cpy sy = sy
    cpy cx = cx
    cpy cy = cy
    cpy ix = idx
    cpy px = (cx + (ix % sx)) - (sx / 2)
    cpy py = (cy + (ix / sx)) - (sy / 2)
    let fn = if cond([cx,cy], [sx,sy], [px,py]): cons<V2>([px,py]) else: {x : List(V2)}x
    let xs = V2.area_aux([cx,cy], ix + 1)
    if ix === (sx * sy): nil<V2> else: fn(xs)
  * nil<V2>

!V2.area : {mlen : Ind, size : !V2, cond : !{cen : V2, siz : V2, pos : V2} -> Word} -> !{pos : V2} -> List(V2)
  V2.area_aux*mlen(#size, #cond, pos, 0)

V2.rect {mlen : Ind, size : !V2} =>
  V2.area(mlen, size, #{cen, siz, pos} 1)

V2.rect.ex
  dup area = V2.rect*(#[4,4])
  # area([100,100])

V2.circle: {mlen : Ind, srad : !Word} -> !{pos : V2} -> List(V2)
  dup srad = srad
  let isin = {cen, siz, pos} (V2.sqr_dist(cen, pos) < srad)
  dup size = #((Num.sqrt(srad) * 2) + 1)
  V2.area(mlen, #[size,size], #isin)

// . . .
// . x .
// . . .
V2.circle_a
  V2.circle(*1, #1)

// . . . . .
// . . x . .
// . x x x .
// . . x . .
// . . . . .
V2.circle_b
  V2.circle(*9, #2)

// . . . . .
// . x x x .
// . x x x .
// . x x x .
// . . . . .
V2.circle_c
  V2.circle(*9, #3)

// . . . . . . .
// . . . x . . .
// . . x x x . .
// . x x x x x .
// . . x x x . .
// . . . x . . .
// . . . . . . .
V2.circle_d
  V2.circle(*25, #5)

// . . . . . . .
// . . x x x . .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . . x x x . .
// . . . . . . .
V2.circle_e
  V2.circle(*25, #6)

// . . . . . . .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . x x x x x .
// . . . . . . .
V2.circle_f
 V2.circle(*49, #9)

// . . . . . . . . .
// . . . . x . . . .
// . . x x x x x . .
// . . x x x x x . .
// . x x x x x x x .
// . . x x x x x . .
// . . x x x x x . .
// . . . . x . . . .
// . . . . . . . . .
V2.circle_g
  V2.circle(*49, #10)

// . . . . . . . . .
// . . . x x x . . .
// . . x x x x x . .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . . x x x x x . .
// . . . x x x . . .
// . . . . . . . . .
V2.circle_h
  V2.circle(*49, #11)

// . . . . . . . . .
// . . x x x x x . .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . x x x x x x x .
// . . x x x x x . .
// . . . . . . . . .
V2.circle_i
  V2.circle(*49, #14)

// . . . . . . . . . . .
// . . . . . x . . . . .
// . . . x x x x x . . .
// . . x x x x x x x . .
// . . x x x x x x x . .
// . x x x x x x x x x .
// . . x x x x x x x . .
// . . x x x x x x x . .
// . . . x x x x x . . .
// . . . . . x . . . . .
// . . . . . . . . . . .
V2.circle_j
  V2.circle*81(#17)

V2.range: {mlen : Ind, rad : !Word} -> !{pos : V2} -> List(V2)
  dup rad  = rad
  let isin = {cen, siz, pos} V2.flat_dist(cen, pos) < (rad + 1)
  dup size = #(rad * 2) + 1
  V2.area*mlen(#[size,size], #isin)

V2.range_0
  V2.range(*1, #0)
V2.range_1
  V2.range(*9, #1)
V2.range_2
  V2.range(*25, #2)
V2.range_3
  V2.range(*49, #3)
V2.range_4
  V2.range(*81, #4)
V2.range_5
  V2.range(*121, #5)
V2.range_6
  V2.range(*169, #6)

!V2.wave*n : dup line = V2.line(*) !{widths : List(Word), pos : V2, dxy : V2} -> List(V2)
  case<List> widths
  | cons =>
    let ws = V2.wave(tail)
    get [ax,ay] = pos
    get [dx,dy] = dxy
    cpy w  = head
    cpy ax = ax
    cpy ay = ay
    cpy dx = dx
    cpy dy = dy
    cpy nx = dy
    cpy ny = 0 - dx
    let ix = ax - (nx * (w / 2))
    let iy = ay - (ny * (w / 2))
    let t  = ws([ax + dx,ay + dy], [dx,dy])
    line(w, [ix,iy], [nx,ny], t)
  | nil => nil<V2>
  : List(V2)
  * nil<V2>
