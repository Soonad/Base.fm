import Base@0

// Recursive Fields
// ----------------

// Fields can refer to the datatype being defined:

// {- From Data.Nat -}
T Nat
| succ {pred : Nat}
| zero

// Since Nat is so common, there is a syntax-sugar for it: 0n3, which expands to succ(succ(succ(zero))).
// Mutual recursion is allowed:

T Foo
| foo {bar : Foo}

T Bar
| bar {foo : Bar}

// And negative occurrences too (soundly):
T Loop
| loop {f : Foo -> Foo}

// While recursion is very liberal on types, the same isn’t true for programs. You can’t write recursive functions directly, such as:

rec_fields.example_0a : {case n : Nat} -> Nat
| succ => succ(succ(rec_fields.example_0a(n)))
| zero => zero

rec_fields.example_0a_test : Nat
  rec_fields.example_0a(0n2)

// This makes dealing with recursive datatypes more complex than usual, since you must use a boxed definition:

#rec_fields.example_0b*N : !{case n : Nat} -> Nat
| succ => succ(succ(rec_fields.example_0b(n)))
| zero => zero
halt: zero

#rec_fields.example_0b_test : !Nat
  <rec_fields.example_0b*>(0n2)

// This is explained in more details on the Boxes and Recursion sections of the Tutorial.







