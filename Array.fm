import Rec@1 open
import Nat@4 open
import Global@2 open

r0 : Rec = halt
r1 : Rec = call(r0)
r2 : Rec = call(r1)
r3 : Rec = call(r2)
r4 : Rec = call(r3)
r5 : Rec = call(r4)
r6 : Rec = call(r5)
r7 : Rec = call(r6)
r8 : Rec = call(r7)

n0 : Nat = zero
n1 : Nat = succ(n0)
n2 : Nat = succ(n1)
n3 : Nat = succ(n2)
n4 : Nat = succ(n3)
n5 : Nat = succ(n4)
n6 : Nat = succ(n5)
n7 : Nat = succ(n6)
n8 : Nat = succ(n7)

Array : {n : Nat} -> Type
  case<Nat> n
  | succ => [x : Array(pred), Array(pred)]
  | zero => U32
  : Type

ArrayR : {r : Rec} -> Type
  Array(open<Nat>(from_rec(r)))

clear_first :! {~n : Nat, *arr : Array(n)} -> Array(n)
  ( case<Nat> n
  | succ => {arr}
    get [a, b] = arr
    [clear_first(~pred, a), b]
  | zero => {val}
    0
  : {arr : Array(self)} -> Array(self))(arr)
  
a0 : Array(n0) = 0
a1 : Array(n1) = [a0, a0]
a2 : Array(n2) = [a1, a1]
a3 : Array(n3) = [a2, a2]
a4 : Array(n4) = [a3, a3]
a5 : Array(n5) = [a4, a4]
a6 : Array(n6) = [a5, a5]
a7 : Array(n7) = [a6, a6]
a8 : Array(n8) = [a7, a7]

rec_plus_nat : {r : Rec, n : !Nat} -> !Nat
  (%r)(~{r}Nat, #{~r}succ, n)

with.type : {D : Rec} -> Type
  { ~n   : Nat
  , path : U32
  , fun  : {arr : Array(n)} -> [el : U32, Array(n)]
  , arr  : Array(open<Nat>(rec_plus_nat(D, #n)))
  }     -> [el : U32, Array(open<Nat>(rec_plus_nat(D, #n)))]

with : {D : Rec} -> !with.type(D)
  let moti = {D} with.type(D)
  let call = {~D, cont, ~n, path, fun}
    // A proof that `âˆ€ (r : Rec) (n : Nat) -> r + succ(n) == call(r) + n`, used internally
    let theo
      : {~r : Rec, ~n : !Nat} -> ! <rec_plus_nat(r, #succ(n)) == rec_plus_nat(call(r), #n)>
      = {~r, ~n} =>
        dup n    = n
        let moti = {r} {n : Nat} -> <rec_plus_nat(r, #succ(n)) == rec_plus_nat(call(r), #n)>
        let call = {~r, f, n} cong<!Nat, !Nat, rec_plus_nat(r, #succ(n)), rec_plus_nat(call(r), #n), boxed<Nat>(#succ), f(n)>
        let halt = {n} refl<succ(n)>
        dup func = (%r)(~moti, #call, #halt)
        # func(n)
    // Swappers to navigate through the tree with the path
    let noswap = {a : Array(n), b : Array(n)} [a, b]
    let doswap = {a : Array(n), b : Array(n)} [b, a]
    // Extends `fun` so that it updates a bigger array
    let result = cont(~succ(n), |path / 2|, {arr}
      get [a, b] = arr
      get [a, b] = (if |path % 2| [doswap, noswap])(a, b)
      get [e, a] = fun(a)
      get [a, b] = (if |path % 2| [doswap, noswap])(a, b)
      [e, [a, b]])
    // Rewrites the return type to make the checker happy
    let e = open<<rec_plus_nat(D, #succ(n)) == rec_plus_nat(call(D), #n)>>(theo<D, #n>)
    rewrite<e>{X in {x : Array(open<Nat>(X))} -> [el : U32, Array(open<Nat>(X))]}(result)
  let halt = {~n, path, fun}
    fun
  (%D)(~moti, #call, #halt)

main
  // Instantiates the update function for an array of 256 elements
  dup w8 = with(r8)

  // Our update function increases the element by `2` and returns the old one
  let fn = {x}
    cpy x = x
    [x, |x + 2|]

  // Updates the 4th element of an array of 256 zeros
  # w8(~zero, 4, fn, a8)
