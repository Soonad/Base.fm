import Rec@1 open
import Nat@4 open
import Global@2 open

r0 : Rec = halt
r1 : Rec = call(r0)
r2 : Rec = call(r1)
r3 : Rec = call(r2)
r4 : Rec = call(r3)
r5 : Rec = call(r4)
r6 : Rec = call(r5)
r7 : Rec = call(r6)
r8 : Rec = call(r7)

n0 : Nat = zero
n1 : Nat = succ(n0)
n2 : Nat = succ(n1)
n3 : Nat = succ(n2)
n4 : Nat = succ(n3)
n5 : Nat = succ(n4)
n6 : Nat = succ(n5)
n7 : Nat = succ(n6)
n8 : Nat = succ(n7)

Array : {n : Nat} -> Type
  case<Nat> n
  | succ => [x : Array(pred), Array(pred)]
  | zero => U32
  : Type

ArrayR : {r : Rec} -> Type
  Array(open<Nat>(from_rec(r)))

clear_first :! {~n : Nat, *arr : Array(n)} -> Array(n)
  ( case<Nat> n
  | succ => {arr}
    get [a, b] = arr
    [clear_first(~pred, a), b]
  | zero => {val}
    0
  : {arr : Array(self)} -> Array(self))(arr)
  
a0 : Array(n0) = 7
a1 : Array(n1) = [a0, a0]
a2 : Array(n2) = [a1, a1]
a3 : Array(n3) = [a2, a2]
a4 : Array(n4) = [a3, a3]
a5 : Array(n5) = [a4, a4]
a6 : Array(n6) = [a5, a5]
a7 : Array(n7) = [a6, a6]
a8 : Array(n8) = [a7, a7]

add_from_rec : {r : Rec, n : !Nat} -> !Nat
  (%r)(~{r}Nat, #{~r}succ, n)

with.type : {D : Rec} -> Type
  { ~n   : Nat
  , path : U32
  , fun  : {x : Array(n)} -> [el : U32, Array(n)]
  , x    : Array(open<Nat>(add_from_rec(D, #n)))
  }     -> [el : U32, Array(open<Nat>(add_from_rec(D, #n)))]

with : {D : Rec} -> !with.type(D)
  // A theorem that is needed internally
  let theo
    : {~r : Rec, ~n : !Nat} -> ! <add_from_rec(r, #succ(n)) == add_from_rec(call(r), #n)>
    = {~r, ~n} =>
      dup n    = n
      let moti = {r} {n : Nat} -> <add_from_rec(r, #succ(n)) == add_from_rec(call(r), #n)>
      let call = {~r, f, n} cong<!Nat, !Nat, add_from_rec(r, #succ(n)), add_from_rec(call(r), #n), boxed<Nat>(#succ), f(n)>
      let halt = {n} refl<succ(n)>
      dup func = (%r)(~moti, #call, #halt)
      # func(n)
  let moti = {D} with.type(D)
  let call = {~D, cont, ~n, path, fun}
    let noswap = {a : Array(n), b : Array(n)} [a, b]
    let doswap = {a : Array(n), b : Array(n)} [b, a]
    let result = cont(~succ(n), |path / 2|, {arr}
      get [a, b] = arr
      get [a, b] = (if |path % 2| [doswap, noswap])(a, b)
      get [e, a] = fun(a)
      get [a, b] = (if |path % 2| [doswap, noswap])(a, b)
      [e, [a, b]])
    // Rewrites the return type to make the checker happy
    let e = open<<add_from_rec(D, #succ(n)) == add_from_rec(call(D), #n)>>(theo<D, #n>)
    rewrite<e>{X in {x : Array(open<Nat>(X))} -> [el : U32, Array(open<Nat>(X))]}(result)
  let halt = {~n, path, fun}
    fun
  (%D)(~moti, #call, #halt)

main
  dup u8 = with(r8)
  let fn = {x}
    cpy x = x
    [x, |x * 2|]
  # u8(~zero, 4, fn, a8)
