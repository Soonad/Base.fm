import Nat
import Path
import The
import Tree

Array(A, n : Nat) : Type
  case n
  | zero => A
  | succ => [x : Array(A, n.pred), Array(A, n.pred)]
  : Type

// ::::::::::::
// :: Getter ::
// ::::::::::::

Getter(A, n : Nat) : Type
  (arr : Array(A, n)) -> A

get.end(~A) : Getter(A, zero)
  (a) => a

get.lft(~A, ~n : -Nat, g : Getter(A, n)) : Getter(A, succ(n))
  (a) => get [x,y] = a; g(x)

get.rgt(~A : Type, ~n : -Nat, g : Getter(A, n)) : Getter(A, succ(n))
  (a) => get [x,y] = a; g(y)

path_getter(~A : Type, ~len : -Nat, path : Path(len)) : Getter(A, len)
  case path
  | pe => get.end(~A)
  | pl => get.lft(~A, ~path.len, path_getter(~A, ~path.len, path.pred))
  | pr => get.rgt(~A, ~path.len, path_getter(~A, ~path.len, path.pred))
  : Getter(A, path.len)

// ::::::::::::
// :: Mutter ::
// ::::::::::::

Mutter(A, n : Nat) : Type
  (arr : Array(A, n), fun : A -> A) -> Array(A, n)

mut.end(~A) : Mutter(A, zero)
  (a, f) => f(a)

mut.lft(~A, ~n : -Nat, g : Mutter(A, n)) : Mutter(A, succ(n))
  (a, f) => get [x,y] = a; [g(x,f),y]

mut.rgt(~A, ~n : -Nat, g : Mutter(A, n)) : Mutter(A, succ(n))
  (a, f) => get [x,y] = a; [x,g(y,f)]

path_mutter(~A, ~len : -Nat, path : Path(len)) : Mutter(A, len)
  case path
  | pe => mut.end(~A)
  | pl => mut.lft(~A, ~path.len, path_mutter(~A, ~path.len, path.pred))
  | pr => mut.rgt(~A, ~path.len, path_mutter(~A, ~path.len, path.pred))
  : Mutter(A, path.len)

// ::::::::::::
// :: Reader ::
// ::::::::::::

Reader(A, n : Nat) : Type
  (arr : Array(A, n), copy : A -> [:A, A]) -> [: Array(A, n), A]

read.end(~A) : Reader(A, zero)
  (a, c) => c(a)

read.lft(~A, ~n : -Nat, r : Reader(A, n)) : Reader(A, succ(n))
  (a, c) => get [x,y] = a; get [x,k] = r(x,c); [[x,y],k]

read.rgt(~A, ~n : -Nat, r : Reader(A, n)) : Reader(A, succ(n))
  (a, c) => get [x,y] = a; get [y,k] = r(y,c); [[x,y],k]

path_reader(~A, ~len : -Nat, path : Path(len)) : Reader(A, len)
  case path
  | pe => read.end(~A)
  | pl => read.lft(~A, ~path.len, path_reader(~A, ~path.len, path.pred))
  | pr => read.rgt(~A, ~path.len, path_reader(~A, ~path.len, path.pred))
  : Reader(A, path.len)

// ::::::::::
// :: Fold ::
// ::::::::::

fold(~A : Type, ~n : -Nat, t : Tree(A -> A -> A, n), arr : Array(A, n)) : A
  case t
  + arr : Array(A, t.n)
  | node =>
    get [arr.x, arr.y] = arr
    let res.x = fold(~A, ~t.n, t.a, arr.x)
    let res.y = fold(~A, ~t.n, t.b, arr.y)
    t.x(res.x, res.y)
  | leaf =>
    arr
  : A

// :::::::::::
// :: Tests ::
// :::::::::::

array.test0.ones : Array(Number, 8n)
  let arr = 1
  let arr = [arr, arr]
  let arr = [arr, arr]
  let arr = [arr, arr]
  let arr = [arr, arr]
  let arr = [arr, arr]
  let arr = [arr, arr]
  let arr = [arr, arr]
  let arr = [arr, arr]
  arr

array.test0.adds : Tree(Number -> Number -> Number, 8n)
  let op = .+.
  let tr = leaf(~Number -> Number -> Number)
  let tr = node(~Number -> Number -> Number, ~0n, op, tr, tr)
  let tr = node(~Number -> Number -> Number, ~1n, op, tr, tr)
  let tr = node(~Number -> Number -> Number, ~2n, op, tr, tr)
  let tr = node(~Number -> Number -> Number, ~3n, op, tr, tr)
  let tr = node(~Number -> Number -> Number, ~4n, op, tr, tr)
  let tr = node(~Number -> Number -> Number, ~5n, op, tr, tr)
  let tr = node(~Number -> Number -> Number, ~6n, op, tr, tr)
  let tr = node(~Number -> Number -> Number, ~7n, op, tr, tr)
  tr

array.test0 : The(Number, 256)
  the(~Number, fold(~Number, ~8n, array.test0.adds, array.test0.ones))
