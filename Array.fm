import Rec@1 open
import Nat@4 open
import Eq@0 open

r0 : Rec = halt
r1 : Rec = call(r0)
r2 : Rec = call(r1)
r3 : Rec = call(r2)
r4 : Rec = call(r3)
r5 : Rec = call(r4)
r6 : Rec = call(r5)
r7 : Rec = call(r6)
r8 : Rec = call(r7)

n0 : Nat = zero
n1 : Nat = succ(n0)
n2 : Nat = succ(n1)
n3 : Nat = succ(n2)
n4 : Nat = succ(n3)
n5 : Nat = succ(n4)
n6 : Nat = succ(n5)
n7 : Nat = succ(n6)
n8 : Nat = succ(n7)

open : {~A : Type, x : !A} -> A
  dup x = x
  x

Array : {n : Nat} -> Type
  case<Nat> n
  | succ => [x : Array(pred), Array(pred)]
  | zero => U32
  : Type

ArrayR : {r : Rec} -> Type
  Array(open<Nat>(from_rec(r)))

clear_first :! {~n : Nat, *arr : Array(n)} -> Array(n)
  ( case<Nat> n
  | succ => {arr}
    get [a, b] = arr
    [clear_first(~pred, a), b]
  | zero => {val}
    0
  : {arr : Array(self)} -> Array(self))(arr)
  
a0 : Array(n0) = 7
a1 : Array(n1) = [a0, a0]
a2 : Array(n2) = [a1, a1]
a3 : Array(n3) = [a2, a2]
a4 : Array(n4) = [a3, a3]
a5 : Array(n5) = [a4, a4]
a6 : Array(n6) = [a5, a5]
a7 : Array(n7) = [a6, a6]
a8 : Array(n8) = [a7, a7]


// def Arr.with: {dpt}
//   let init = {path fn} fn
//   let loop = {cont path fn}
//     cpy path = path
//     get [swap0,swap1] =
//       if |path % 2|
//       then: [{x}x, {x}x]
//       else: [Pair.swap, Pair.swap]
//     (cont |path / 2| {arr}
//       get [a,b] = (swap0 arr)
//       get [b,x] = (fn b)
//       [(swap1 [a,b]), x])
//   let stop = {func} func
//   dup fold = (for dpt #init #loop #stop)
//   # {path fn arr} (fold path fn arr)


add_from_rec : {r : Rec, n : !Nat} -> !Nat
  (%r)(~{r}Nat, #{~r}succ, n)

theo.f : {r : Rec, n : Nat} -> !Nat
  add_from_rec(r, #succ(n))

theo.g : {r : Rec, n : Nat} -> !Nat
  add_from_rec(call(r), #n)

bsucc : {x : !Nat} -> !Nat
  dup x = x
  # succ(x)

theo : {r : Rec, n : !Nat} -> !Eq(!Nat, theo.f(r, open<Nat>(n)), theo.g(r, open<Nat>(n)))
  dup n    = n
  let moti = {r} {n : Nat} -> Eq(!Nat, theo.f(r, n), theo.g(r, n))
  let call = {~r, f, n} cong<!Nat, !Nat, theo.f(r, n), theo.g(r, n)>(f(n), ~bsucc)
  let halt = {n} refl<!Nat, bsucc(#n)>
  //let call = {~r, f, n} cong<Nat, Nat, theo.f(r, n), theo.g(r, n)>(f(n), ~succ)
  //let halt = {n} refl<Nat, succ(n)>
  dup func = (%r)(~moti, #call, #halt)
  # func(n)

update {D : Rec}
  let moti = {D} {~n : Nat, path : U32, fun : {x : Array(n)} -> Array(n)} -> {x : Array(open<Nat>(add_from_rec(D, #n)))} -> Array(open<Nat>(add_from_rec(D, #n)))
  let call = {~D, cont, ~n, path, fun}
    //- Found type... {x : Array(open(~Nat, add_from_rec(D, #succ(n))))} -> Array(open(~Nat, add_from_rec(D, #succ(n))))
    //- Instead of... {x : Array(open(~Nat, add_from_rec(call(D), #n)))} -> Array(open(~Nat, add_from_rec(call(D), #n)))
    //rewrite : {~A : Type, ~a : A, ~b : A, e : Eq(A, a, b), ~P : {a : A} -> Type, x : P(a)} -> P(b)
    rewrite(~Nat, ~theo.f(D, #n), ~theo.g(D, #n), theo(D, #n), ~{k} {x : Array(open<Nat>(k))} -> Array(open<Nat>(k)),
      cont(~succ(n), path, {arr} arr))
  let halt = {~n, path, fun}
    fun
  (%D)(~moti, #call, #halt)

main
  theo
  //update
  //dup update = update(r8)
  //# update(0,  a8)

  //let array = a8
  //# update(~n8, 0, {x}70, a8)
    //a8

//main :! Array(n3)
  //update

  //unbox clear_first
  //clear_first<n3>([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
