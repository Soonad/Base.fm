// TODO: update

import Boxes@0 open
import Nat@8 open
import Rec@3 open

Array : {n : Nat} -> Type
  case<Nat> n
  | succ => [x : Array(pred), Array(pred)]
  | zero => Word
  : Type

a0 : Array(0n0) 0
a1 : Array(0n1) [a0, a0]
a2 : Array(0n2) [a1, a1]
a3 : Array(0n3) [a2, a2]
a4 : Array(0n4) [a3, a3]
a5 : Array(0n5) [a4, a4]
a6 : Array(0n6) [a5, a5]
a7 : Array(0n7) [a6, a6]
a8 : Array(0n8) [a7, a7]

rec_plus_nat : {r : Rec, n : !Nat} -> !Nat
  rep(r, ~Nat, #succ, n)

with.type : {D : Rec} -> Type
  { ~n   : Nat
  , path : Word
  , fun  : {arr : Array(n)} -> [el : Word, Array(n)]
  , arr  : Array(unbox<Nat>(rec_plus_nat(D, #n)))
  }     -> [el : Word, Array(unbox<Nat>(rec_plus_nat(D, #n)))]

with.theo : {~r : Rec, ~n : !Nat} -> ! rec_plus_nat(r, #succ(n)) == rec_plus_nat(call(r), #n)
  dup n    = n
  let moti = {r} {n : Nat} -> rec_plus_nat(r, #succ(n)) == rec_plus_nat(call(r), #n)
  let call = {~r, f, n} cong<!Nat, !Nat, rec_plus_nat(r, #succ(n)), rec_plus_nat(call(r), #n), boxed<Nat>(#succ), f(n)>
  let halt = {n} refl<succ(n)>
  dup func = (%r)(~moti, #call)
  # func(halt, n)

with : {D : Rec} -> !with.type(D)
  let moti = {D} with.type(D)
  let call = {~D, cont, ~n, path, fun}
    // Swappers to navigate through the tree with the path
    let noswap = {a : Array(n), b : Array(n)} [a, b]
    let doswap = {a : Array(n), b : Array(n)} [b, a]
    // Extends `fun` so that it updates a bigger array
    let result = cont(~succ(n), path / 2, {arr}
      get [a, b] = arr
      get [a, b] = (if path % 2 [doswap, noswap])(a, b)
      get [e, a] = fun(a)
      get [a, b] = (if path % 2 [doswap, noswap])(a, b)
      [e, [a, b]])
    // Rewrites the return type to make the checker happy
    let e = unbox<rec_plus_nat(D, #succ(n)) == rec_plus_nat(call(D), #n)>(with.theo<D, #n>)
    rewrite<e>{X in {x : Array(unbox<Nat>(X))} -> [el : Word, Array(unbox<Nat>(X))]}(result)
  let halt = {~n, path, fun}
    fun
  dup func = (%D)(~moti, #call)
  # func(halt)
