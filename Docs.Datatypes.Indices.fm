import Base@0

//  Indices
//  -------

// Indices are like polymorphic variables, except that, rather than constant types, they are computed values that can depend on each constructor’s arguments. That gives us a lot of type-level power, and is one of the reasons Formality is a great proof language. For example:

T IsEven (x : Word)
| make_even {half : Word} (half * 2)

// This datatype has one index, x, of type Word. Its constructor, is_even, has one field, half : Word. When you write make_even(3), the number 3 is multiplied by two and moved to the type-level, resulting in a value of type IsEven(6). So, for example:

even_0 : IsEven(0)
  make_even(0)

even_2 : IsEven(2)
  make_even(1)

even_4 : IsEven(4)
  make_even(2)

even_6 : IsEven(6)
  make_even(3)

// Notice that it is impossible to create a value with type IsEven(3), because that would require a half : Word such that half * 2 == 3, and there is no such number. Because of that, indexed datatypes have many applications. For example, suppose that you want to write a div2 function that divides a number by two, but you don’t want it to be called with odd numbers. You could do this:

indice.example_0 : {x : Word, ~x_is_even : IsEven(x)} -> Word
  x / 2

indice.example_0_test : Word
  indice.example_0(10, ~make_even(5))

// Here, the second argument “proves” that the first is even, making it impossible to call div2 with an odd input. Since x_is_even is erased from the runtime, this gives us a static, zero-cost guarantee. Alternatively, we could have used ~x_is_even : [k : Word ~ x == k * 2], but indexed datatypes are more handy in general. For example, you could easily write one for 3 consecutive numbers:

T Consecutive (a : Word, b : Word, c : Word)
| consecutive {init : Word} (init, init + 1, init + 2)

// So, for example, Consecutive(a, b, c) means a, b, c are 3 consecutive numbers such as 7, 8, 9. You could also write a type for sorted lists:

T SortedList {A : Type} (xs : List(Word))
| scons {
  add  : Word,
  head : Word,
  tail : List(Word),
  prof : SortedList(cons(~Word, head, tail))
} (cons(~Word, head + add, cons(~Word, head, tail)))
| snil (nil(~Word))

// Here, SortedList(xs) would mean that xs is a list of Words with elements in descending order, such as [7, 5, 5, 3, 1]. In order words, a function that returned [xs : List(Word) ~ SortedList(xs)] could only be written if xs was, indeed, sorted. And so on. Indexed datatypes, in a way, give us a powerful language of specifications which we can use to statically reason about our datatypes and algorithms.





