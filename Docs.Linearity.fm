import Base

// ## Linearity

// Formality's approach to termination is what makes it different from other proof languages like Agda, Idris and Coq. Instead of having native datatypes, structural recursion and so on, we go deeper and change the underlying logic of the system from intuitionist to elementary affine. This is responsible for all the claimed benefits of Formality: optimal reductions, no garbage-collection, massive parallelism, elegant inductive types and so on. But it comes with a huge tradeoff: our lambdas are affine, i.e., bound variables can't be used more than once. This limits what we can do in multiple ways. For example, we can't write a function that `and`s a `Bool` with itself:s

// linearity.example_0 : {x : Bool} -> Bool
//   and(x, x)

// linearity.example_0_test : Bool
//   linearity.example_0(true)


// If we try to check the type using `fm -t <file_name>/linearity.example_0`, we get an error:

// ```shell
// Lambda variable `x` used more than once in:
// {x} => and(x, x)
// ```

// There are multiple ways to avoid this situation.
