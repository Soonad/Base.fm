import Data.Function
import Category

//functionEq : {A:Type, B:Type, f:Fun(A,B), g:Fun(A,B)
//             , e:{x:A} -> f(x) == g(x)
//             , em: Empty 
//             } -> f == g
//  absurd(em, f == g)
//
//associative : {A:Type, B:Type, C:Type, D:Type
//              , f:Fun(A,B), g:Fun(B,C), h:Fun(C,D)
//              , em:Empty
//              } -> compose(A,C,D,h,compose(A,B,C,g,f)) ==
//                     compose(A,B,D,compose(B,C,D,h,g),f)
//  absurd(em, compose(A,C,D,h,compose(A,B,C,g,f)) ==
//               compose(A,B,D,compose(B,C,D,h,g),f)
//        )
//
//function.id : {A:Type} -> Fun(A,A)
//  {x:A} x
//
//identity : {A:Type, em:Empty} -> 
//           [id:Fun(A,A)
//           , And({B:Type, f:Fun(A,B)} -> compose(A,A,b,f,id) == f
//                ,{B:Type, g:Fun(B,A)} -> compose(B,A,A,id,g) == g
//                )
//           ]
//absurd(em
//      , [id:Fun(A,A)
//           , And({B:Type, f:Fun(A,B)} -> compose(A,A,B,f,id) == f
//                ,{B:Type, g:Fun(B,A)} -> compose(B,A,A,id,g) == g
//                )
//           ]
//      )

//type.category : Category(Type, Fun)
//  mkCategory(compose, associative, identity)
