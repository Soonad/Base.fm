import Algebra.Semigroup
import Data.Function
import Logic

T Monoid {A : Type, s : Setoid(A)}
| monoid
  { f           : Op2(A)
  , e           : A
  , associative : Associative(A,s,f)
  , identity    : Identity(A,s,f,e)
  }

// Monoids are Semigroups
monoid_to_semigroup :
  {~A : Type
  ,~s : Setoid(A)
  , case m : Monoid(A,s)
  } -> Semigroup(A,s)
| monoid => semigroup(~A,~s,m.f, m.associative)

T AbelianMonoid {A : Type, s : Setoid(A)}
| abelian_monoid
  { f           : Op2(A)
  , e           : A
  , associative : Associative(A,s,f)
  , identity    : Identity(A,s,f,e)
  , commutative : Commutative(A,s,f)
  }

T IdempotentMonoid {A : Type, s : Setoid(A)}
| idempotent_monoid
  { f           : A -> A -> A
  , e           : A
  , associative : Associative(A,s,f)
  , identity    : Identity(A,s,f,e)
  , idempotent  : Idempotent(A,s,f)
  }

// Dual monoid
monoid.dual : {~A : Type, ~s : Setoid(A), case m : Monoid(A,s)} -> Monoid(A,s)
| monoid =>
  let g = {x,y} m.f(y,x)
  let left_id = LeftIdentity(A,s,m.f,m.e)
  let right_id = RightIdentity(A,s,m.f,m.e)
  let assoc = dual.associative(~A,~s,~m.f,m.associative)
  let identity = And.commutation(~left_id, ~right_id, m.identity)
  monoid(~A,~s,g,m.e,assoc,identity)

dual.associative :
  { ~A : Type
  , case ~s : Setoid(A)
  , ~f : Op2(A)
  , a : Associative(A,s,f)
  } -> Associative(A,s,{x,y} f(y,x))
| setoid => case/Equivalence s.equivalence as se
  | equivalence => {x,y,z} se.symmetric(~(f(f(z,y),x)),~(f(z,f(y,x))),~a(z,y,x))
  : {x : A, y : A, z : A} -> s.R(f(z,f(y,x)), f(f(z,y),x))



