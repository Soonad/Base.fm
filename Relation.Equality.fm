import Relation.Binary

// The equality type is built-in
Eq : {A : Type, a : A, b : A} -> Type
  a == b

// Built-in symmetry
e_sym : {~A : Type, ~a : A, ~b : A, e : a == b} -> b == a
  sym(e)

// Built-in substitution
e_subst : {~A : Type, ~a : A, ~b : A, e : a == b, ~P : A -> Type, x : P(a)} -> P(b)
  x :: rewrite x in P(x) with e

// Built-in congruence
e_cong : {~A : Type, ~B : Type, ~a : A, ~b : A, ~f : A -> B, e : a == b} -> f(a) == f(b)
  cong(~f, e)

// Built-in transitivity
e_trans : {~A : Type, ~a : A, ~b : A, ~c : A, ab : a == b, bc : b == c} -> a == c
  ab :: rewrite x in a == x with bc

// Non-builtin propositional equality
T Equal {A : Type, a : A} (b : A)
| eq_refl (a)

// Symmetry
eq_sym : {~A : Type, ~a : A, ~b : A, e : Equal(A, a, b)} -> Equal(A, b, a)
  case/Equal e
  | eq_refl => eq_refl(~A, ~a)
  : Equal(A, e.b, a)

// Substitution
eq_subst : {~A : Type, ~a : A, ~b : A, e : Equal(A, a, b), ~P : A -> Type, x : P(a)} -> P(b)
  case/Equal e
  | eq_refl => x
  : P(e.b)

// Congruence
eq_cong : {~A : Type, ~B : Type, ~a : A, ~b : A, ~f : A -> B, e : Equal(A, a, b)} -> Equal(B, f(a), f(b))
  case/Equal e
  | eq_refl => eq_refl(~B, ~f(a))
  : Equal(B, f(a), f(e.b))

// Transitivity
eq_trans : {~A : Type, ~a : A, ~b : A, ~c : A, ab : Equal(A, a, b), bc : Equal(A, b, c)} -> Equal(A, a, c)
  case/Equal bc
  | eq_refl => ab
  : Equal(A, a, bc.b)

// Converts eq to EQ
eq_to_e : {~A : Type, ~a : A, ~b : A, e : a == b} -> Equal(A, a, b)
  eq_refl(~A, ~a) ::
    rewrite x
    in $self
      { ~P      : {b : A, wit : Equal(A, a, b)} -> Type
      , eq_refl : P(a, eq_refl(~A, ~a))
      } -> P(x, self)
    with e
