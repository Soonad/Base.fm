// The equality type is built-in
Eq : {~A : Type, ~a : A, ~b : A} -> Type
  a == b

// Symmetry is built-in
symmetry : {~A : Type, ~a : A, ~b : A, ~e : a == b} -> b == a
  sym(~e)

// Substitution is built-in
subst : {~A : Type, ~a : A, ~b : A, ~e : a == b, ~P : A -> Type, x : P(a)} -> P(b)
  x :: rewrite x in P(x) with e

// Congruence (`a == b` implies `f(a) == f(b)`)
cong : {~A : Type, ~B : Type, ~a : A, ~b : A, ~f : A -> B, ~e : a == b} -> f(a) == f(b)
  refl(~f(a)) :: rewrite x in f(a) == f(x) with e

// Transitivity
trans : {~A : Type, ~a : A, ~b : A, ~c : A, ab : a == b, bc : b == c} -> a == c
  ab :: rewrite x in a == x with bc

// Non-builtin propositional equality
T Equal {A : Type, a : A} (b : A)
| reflect (a)

// Converts eq to EQ
equal : {~A : Type, ~a : A, ~b : A, ~e : a == b} -> Equal(A, a, b)
  reflect(~A, ~a) ::
    rewrite x
    in $self
      { ~P      : {b : A, wit : Equal(A, a, b)} -> Type
      , reflect : P(a, reflect(~A, ~a))
      } -> P(x, self)
    with e

// Extensional Equality
T ExtEq <A : Type, B : Type>
| extEq
   { f     : A -> B
   , g     : A -> B
   , axiom : {x : A} -> f(x) == g(x)
   }
