import Base

// ## Theorem Proving

// **TODO**: review and update with correct error messages (after the `Hole` update). Also talk about `log(x)`.

// ### Simple proofs

// Let's prove a theorem about the boolean `not`:

// simple_proof.example_0 : {b : Bool} -> not(not(b)) == b
//   ?

// Evaluate it using `fm -t <file>/simple_proof.example_0` and the type checker complains:

// ```shell
// [ERROR]
// Hole found.
// - With goal... not(not(b)) == b
// - Inside of... {b} => ?
// - With context:
// - b : Bool

// {b : Bool} -> not(not(b)) == b
// ```

// Let's pattern-match on `b`.

// main : {b : Bool} -> not(not(b)) == b
//   case/Bool b
//   | true  => ?
//   | false => ?
//   : not(not(b)) == b

// Not helpful:

// ```shell
// [ERROR]
// Hole found.
// - With goal... not(not(b)) == b
// - Inside of... (%b)(~{self} => not(not(b)) == b, ?)
// - With context:
// - b : Bool

// [ERROR]
// Hole found.
// - With goal... not(not(b)) == b
// - Inside of... (%b)(~{self} => not(not(b)) == b, ?, ?)
// - With context:
// - b : Bool

// {b : Bool} -> not(not(b)) == b
// ```

// Using `self` on the motive:

// main : {b : Bool} -> not(not(b)) == b
//   case/Bool b
//   | true  => ?
//   | false => ?
//   : not(not(self)) == self

// Progress, `b`s is specialized `true` on the expected type of the `true` branch:

// ```shell
// [ERROR]
// Hole found.
// - With goal... not(not(true)) == true
// - Inside of... (%b)(~{self} => not(not(self)) == self, ?)
// - With context:
// - b : Bool

// [ERROR]
// Hole found.
// - With goal... not(not(false)) == false
// - Inside of... (%b)(~{self} => not(not(self)) == self, ?, ?)
// - With context:
// - b : Bool

// {b : Bool} -> not(not(b)) == b
// ```

// If we reduce both sides, we get the same expression: `{true, false} => true`. In this case, we can use `refl`:

// main : {b : Bool} -> not(not(b)) == b
//   case/Bool b
//   | true  => refl(~true)
//   | false => ?
//   : not(not(self)) == self


// Progress, compiler now complains about the `false` branch:

// ```shell
// [ERROR]
// Hole found.
// - With goal... not(not(false)) == false
// - Inside of... (%b)(~{self} => not(not(self)) == self, refl(~true), ?)
// - With context:
// - b : Bool

// {b : Bool} -> not(not(b)) == b
// ```

// We can do the same:


// main : {b : Bool} -> not(not(b)) == b
//   case/Bool b
//   | true  => refl(~true)
//   | false => refl(~false)
//   : not(not(self)) == self

// No type error. Our proof is complete! Note that, if we used `case`'d args, Formality would fill the `self` on the motive for us. The proof becomes just:

simple_proof.example_0 : {case b : Bool} -> not(not(b)) == b
| true  => refl(~true)
| false => refl(~false)
