// ## The Stratification Condition

// The primitives above, without restriction, would be dangerous. For example, this:

// strat_condition.example_0
//   let f = {x}
//     dup x = x
//     x(#x)
//   f(#f)

// Would loop forever, which should never happen in a terminating language. To solve that, Formality relies on the **stratification condition**. In short, it enforces the following invariant:

// > The level of a term can never change during the program evaluation.

// Where the level of a term is the number of boxes "wrapping" it.

// ### Counting the level of a term

// To understand the restriction above, you must be able to count the level of a term. Let's do it on the following example:

// ```haskell
// ["a", #"b", "c", #["d", #"e"], ##"f"]
// ```

// - The string `"a"` isn't wrapped by any box. It is on `level 0`.
// - The string `"b"` is wrapped by one box. It is on `level 1`.
// - The string `"c"` isn't wrapped by any box. It is on `level 0`.
// - The string `"d"` is wrapped by one box. It is on `level 1`.
// - The string `"e"` is wrapped by two boxes (one indirect). It is on `level 2`. 
// - The string `"f"` is wrapped by two boxes. It is on `level 2`. 

// The type of the program above is:

// ```haskell
// [:String, :!String, :String, :![:String, !String], !!String]
// ```

// ### Stratification examples

// This condition is imposed globally, forbidding certain programs. For example:

// strat_condition.example_1 : {x : Word} -> !Word 
//   # x

// This isn't allowed because, otherwise, we would be able to increase the level of a word. Similarly, this:

// strat_condition.example_2 : [:Word, Word]
//   dup x = #42
//   [x, x]

// Isn't allowed too, because `42` would jump from `level 1` to `level 0` during runtime. But this:

strat_condition.example_3 : ![:Word, Word]
  dup x = #42
  # [x, x]

// Is fine, because `42` remains on `level 1` after being copied. And this:

strat_condition.example_4 : [:!Word, !Word]
  dup x = #42
  [#x, #x]

// Is fine too, for the same reason.
