import Unit open
import Empty open

T Bool
| true
| false

// Simple not
not : {b : Bool} -> Bool
  @ b     ~> Bool
  | true  => false
  | false => true

// Not with runtime fusion
not-f : {b : Bool} -> Bool
  new<Bool>{~P, true, false}
    @ b     ~> P(not-f(self))
    | true  => false
    | false => true

// Simple and
and : {b0 : Bool, b1 : Bool} -> Bool
  (@ b0     ~> Bool -> Bool
  | true    => {b1} @Bool b1 ~> Bool
    | true  => true
    | false => false
  | false   => {b1} @Bool b1 ~> Bool
    | true  => false
    | false => false)(b1)

// Simple or
or : {b0 : Bool, b1 : Bool} -> Bool
  (@ b0      ~> Bool -> Bool
  | true     => {b1} @Bool b1 ~> Bool
    | true   => true
    | false  => true
  | false    => {b1} @Bool b1 ~> Bool
    | true   => true
    | false  => false)(b1)

// If-then-else
bif : {b : Bool, ~P : Type, T : P, F : P} -> P
  (%b)(~{b}P, T, F)

true_not_false : {e : true == false} -> Empty
  let motive = {b : Bool} =>
    @ b     ~> Type
    | true  => Unit
    | false => Empty
  rewrite<e>{x in motive(x)}(unit)

different_elem : {a : Bool} -> [b : Bool, ~{:a == b} -> Empty]
  @ a     ~> [b : Bool, ~{:self == b} -> Empty]
  | true  => [false, ~true_not_false]
  | false => [true, ~{e : false == true} => true_not_false(sym<e>)]
