import Empty
import Equal
import Unit

T Bool
| true
| false

copy(b : Bool) : [:Bool, Bool]
  case b
  | true  => [true, true]
  | false => [false, false]
  : [:Bool, Bool]

not(b : Bool) : Bool
  case b
  | true  => false
  | false => true
  : Bool

and(a : Bool, b : Bool) : Bool
  case a
  | true  => b
  | false => false
  : Bool

or(a : Bool, b : Bool) : Bool
  case a
  | true  => true
  | false => b
  : Bool

nand(a : Bool, b : Bool) : Bool
  case a
  | true  => not(b)
  | false => true
  : Bool

nor(a : Bool, b : Bool) : Bool
  case a
  | true  => false
  | false => not(b)
  : Bool

xor(a : Bool, b : Bool) : Bool
  case a
  + b : Bool
  | true  => case b
    | true  => false
    | false => true
    : Bool
  | false => case b
    | true  => true
    | false => false
    : Bool
  : Bool

// Not with runtime fusion
not_f(b : Bool) : Bool
  new(~Bool) (~P, true, false) =>
    case b
    | true  => false
    | false => true
    : P(not_f(b))

// ::::::::::::::
// :: Theorems ::
// ::::::::::::::

true_isnt_false : Not(Equal(Bool, true, false))
  let rewriter = (x) =>
    case x
    | true  => Unit
    | false => Empty
    : Type
  (e) => rewrite(~Bool, ~true, ~false, e, ~rewriter, unit)

false_isnt_true : Not(Equal(Bool, false, true))
  let rewriter = (x) =>
    case x
    | true  => Empty
    | false => Unit
    : Type
  (e) => rewrite(~Bool, ~false, ~true, e, ~rewriter, unit)

different_elem(a : Bool) : [b : Bool ~ Not(Equal(Bool, a, b))]
  case a
  | true  => [false ~ true_isnt_false]
  | false => [true  ~ false_isnt_true]
  : [b : Bool ~ Not(Equal(Bool, a, b))]

demorgan_0(a : Bool, b : Bool) : Equal(Bool, not(or(a,b)), and(not(a), not(b)))
  case a
  + b : Bool
  | true => case b
    | true  => refl(~Bool, ~false)
    | false => refl(~Bool, ~false)
    : Equal(Bool, not(or(true,b)), and(not(true), not(b)))
  | false => case b
    | true  => refl(~Bool, ~false)
    | false => refl(~Bool, ~true)
    : Equal(Bool, not(or(false,b)), and(not(false), not(b)))
  : Equal(Bool, not(or(a,b)), and(not(a), not(b)))

demorgan_1(a : Bool, b : Bool) : Equal(Bool, not(and(a,b)), or(not(a), not(b)))
  case a
  + b : Bool
  | true => case b
    | true  => refl(~Bool, ~false)
    | false => refl(~Bool, ~true)
    : Equal(Bool, not(and(true,b)), or(not(true), not(b)))
  | false => case b
    | true  => refl(~Bool, ~true)
    | false => refl(~Bool, ~true)
    : Equal(Bool, not(and(false,b)), or(not(false), not(b)))
  : Equal(Bool, not(and(a,b)), or(not(a), not(b)))
