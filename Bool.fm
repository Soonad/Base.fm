import Unit open

T Bool
| true
| false

.!! : Bool -> Bool; not
.F : {x : Bool} -> Bool; false
.T : {x : Bool} -> Bool; true

// Simple not
not : {b : Bool} -> Bool
  case<Bool> b
  | true  => false
  | false => true
  : Bool

// Not with runtime fusion
not-f : {b : Bool} -> Bool
  new<Bool>{~P, true, false}
    case<Bool> b
    | true  => false
    | false => true
    : P(not-f(self))

// Binary operations
binop : { r00 : Bool, r01 : Bool, r10 : Bool, r11 : Bool
        , b0 : Bool, b1 : Bool
        } -> Bool
  ( case<Bool> b0
  | true => {b1} case<Bool> b1
    | true  => r11
    | false => r10
    : Bool
  | false => {b1} case<Bool> b1
    | true  => r01
    | false => r00
    : Bool
  : Bool -> Bool)(b1)

and  : {b0 : Bool, b1 : Bool} -> Bool; binop(false, false, false, true,  b0, b1)
or   : {b0 : Bool, b1 : Bool} -> Bool; binop(false, true,  true,  true,  b0, b1)
nand : {b0 : Bool, b1 : Bool} -> Bool; binop(true,  true,  true,  false, b0, b1)
nor  : {b0 : Bool, b1 : Bool} -> Bool; binop(true,  false, false, false, b0, b1)
xor  : {b0 : Bool, b1 : Bool} -> Bool; binop(false, true,  true,  false, b0, b1)
xnor : {b0 : Bool, b1 : Bool} -> Bool; binop(true,  false, false, true,  b0, b1)

.&& : Bool -> Bool -> Bool; and
.|| : Bool -> Bool -> Bool; or
.!& : Bool -> Bool -> Bool; nand
.!| : Bool -> Bool -> Bool; nor
./= : Bool -> Bool -> Bool; xor
.== : Bool -> Bool -> Bool; xnor

// If-then-else
bif : {b : Bool, ~P : Type, T : P, F : P} -> P
  (%b)(~{b}P, T, F)

true_not_false : {e : true == false} -> Empty
  let motive = {b : Bool} =>
    case<Bool> b
    | true => Unit
    | false => Empty
    : Type
  rewrite<e>{x in motive(x)}(new)

different_elem : {a : Bool} -> [b : Bool, ~{:a == b} -> Empty]
  case<Bool> a
  | true => [false, ~true_not_false]
  | false => [true, ~{e : false == true} => true_not_false(sym<e>)]
  : [b : Bool, ~{:self == b} -> Empty]
