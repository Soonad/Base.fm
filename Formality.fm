// A ideia é que o Formality-Lang compila para o
// Formality-Core para fins de type-checking apenas. O
// Formality-Lang tem coisas tipo ADTs e números, enquanto o
// Formality-Core só tem lambdas e self. Para virar
// JavaScript, a compilação parte do Formality-Lang, de modo
// a poder usar os números e ADTs nele presentes.

import Bits
import IO
import Map
import Nat
import Number
import String
import Unit

// :::::::::::
// :: Utils ::
// :::::::::::

Lazy(A : Type) : Type
  Unit -> A

force(A; x: Lazy(A)) : A
  x(unit)

// ::::::::::
// :: Term ::
// ::::::::::

T Term
| typ
| var(indx: Nat)
| ref(name: String, eras: Bool)
| all(name: String, bind: Term, body: Term, eras: Bool)
| lam(name: String, body: Term, eras: Bool)
| app(func: Term, argm: Term, eras: Bool)
| slf(name: String, type: Term)
| ins(type: Term, expr: Term)
| eli(expr: Term)
| ann(type: Term, expr: Term, done: Bool)
  
T Def
| def(type: Term, term: Term)

Defs : Type
  Map(Def)

// ::::::::::::::::::
// :: Substitution ::
// ::::::::::::::::::

shift(term: Term, inc: Nat, dep: Nat) : Term
  case term
  | typ =>
    typ
  | var =>
    case nat_compare(term.indx, dep) as cmp
    | less_than    => var(term.indx)
    | equal_to     => var(add(inc, term.indx))
    | greater_than => var(add(inc, term.indx))
  | ref =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)
  | all =>
    let name = term.name
    let bind = shift(term.bind, inc, dep)
    let body = shift(term.body, inc, succ(dep))
    let eras = term.eras
    all(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = shift(term.body, inc, succ(dep))
    let eras = term.eras
    lam(name, body, eras)
  | app =>
    let func = shift(term.func, inc, dep)
    let argm = shift(term.argm, inc, dep)
    let eras = term.eras
    app(func, argm, eras)
  | slf =>
    let name = term.name
    let type = shift(term.type, inc, succ(dep))
    slf(name, type)
  | ins =>
    let type = shift(term.type, inc, dep)
    let expr = shift(term.expr, inc, dep)
    ins(type, expr)
  | eli =>
    let expr = shift(term.expr, inc, dep)
    eli(expr)
  | ann =>
    let type = shift(term.type, inc, dep)
    let expr = shift(term.expr, inc, dep)
    let done = term.done
    ann(type, expr, done)

subst(term: Term, trm: Term, dep: Nat) : Term
  case term
  | typ =>
    typ
  | var =>
    case nat_compare(term.indx, dep) as cmp
    | less_than    => var(term.indx)
    | equal_to     => trm
    | greater_than => var(pred(term.indx))
  | ref =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)
  | all =>
    let name = term.name
    let bind = subst(term.bind, trm, dep)
    let body = subst(term.body, shift(trm,1n,0n), succ(dep))
    let eras = term.eras
    all(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = subst(term.body, shift(trm,1n,0n), succ(dep))
    let eras = term.eras
    lam(name, body, eras)
  | app =>
    let func = subst(term.func, trm, dep)
    let argm = subst(term.argm, trm, dep)
    let eras = term.eras
    app(func, argm, eras)
  | slf =>
    let name = term.name
    let type = subst(term.type, shift(trm,1n,0n), succ(dep))
    slf(name, type)
  | ins =>
    let type = subst(term.type, trm, dep)
    let expr = subst(term.expr, trm, dep)
    ins(type, expr)
  | eli =>
    let expr = subst(term.expr, trm, dep)
    eli(expr)
  | ann =>
    let type = subst(term.type, trm, dep)
    let expr = subst(term.expr, trm, dep)
    let done = term.done
    ann(type, expr, done)

subst_many(term: Term, vals: List(Term), inc: Nat, dep: Nat) : Term
  case vals
  | nil =>
    term
  | cons =>
    let sval = shift(vals.head, inc, 0n)
    let sdep = add(dep, inc)
    let term = subst(term, sval, sdep)
    subst_many(term, vals.tail, pred(inc), dep)

// :::::::::::::::::::
// :: Normalization ::
// :::::::::::::::::::

T Hoas
| typx
| varx(indx: Nat)
| refx(name: String, eras: Bool)
| allx(name: String, bind: Hoas, body: Hoas -> Hoas, eras: Bool)
| lamx(name: String, body: Hoas -> Hoas, eras: Bool)
| appx(func: Hoas, argm: Hoas, eras: Bool)
| slfx(name: String, type: Hoas -> Hoas)
| insx(type: Hoas, expr: Hoas)
| elix(expr: Hoas)
| annx(type: Hoas, expr: Hoas, done: Bool)

term_to_hoas(term: Term, vals: List(Hoas)) : Hoas
  case term
  | typ =>
    typx
  | var =>
    case at(Hoas; term.indx, vals) as got
    | none => varx(term.indx)
    | some => got.value
  | ref =>
    let name = term.name
    let eras = term.eras
    refx(name, eras)
  | all =>
    let name = term.name
    let bind = term_to_hoas(term.bind, vals)
    let body = (x) => term_to_hoas(term.body,cons(_ x,vals))
    let eras = term.eras
    allx(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = (x) => term_to_hoas(term.body,cons(_ x,vals))
    let eras = term.eras
    lamx(name, body, eras)
  | app =>
    let func = term_to_hoas(term.func, vals)
    let argm = term_to_hoas(term.argm, vals)
    let eras = term.eras
    appx(func, argm, eras)
  | slf =>
    let name = term.name
    let type = (x) => term_to_hoas(term.type, cons(_ x, vals))
    slfx(name, type)
  | ins =>
    let type = term_to_hoas(term.type, vals)
    let expr = term_to_hoas(term.expr, vals)
    insx(type, expr)
  | eli =>
    let expr = term_to_hoas(term.expr, vals)
    elix(expr)
  | ann =>
    let type = term_to_hoas(term.type, vals)
    let expr = term_to_hoas(term.expr, vals)
    let done = term.done
    annx(type, expr, done)

hoas_to_term(term: Hoas, depth: Nat) : Term
  case term
  | typx =>
    typ
  | varx =>
    case nat_compare(term.indx, depth) as cmp
    | less_than    => var(sub(depth, succ(term.indx)))
    | equal_to     => var(term.indx)
    | greater_than => var(term.indx)
  | refx =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)
  | allx =>
    let name = term.name
    let bind = hoas_to_term(term.bind, depth)
    let body = hoas_to_term(term.body(varx(depth)), succ(depth))
    let eras = term.eras
    all(name, bind, body, eras)
  | lamx =>
    let name = term.name
    let body = hoas_to_term(term.body(varx(depth)), succ(depth))
    let eras = term.eras
    lam(name, body, eras)
  | appx =>
    let func = hoas_to_term(term.func, depth)
    let argm = hoas_to_term(term.argm, depth)
    let eras = term.eras
    app(func, argm, eras)
  | slfx =>
    let name = term.name
    let type = hoas_to_term(term.type(varx(depth)), succ(depth))
    slf(name, type)
  | insx =>
    let type = hoas_to_term(term.type, depth)
    let expr = hoas_to_term(term.expr, depth)
    ins(type, expr)
  | elix =>
    let expr = hoas_to_term(term.expr, depth)
    eli(expr)
  | annx =>
    let type = hoas_to_term(term.type, depth)
    let expr = hoas_to_term(term.expr, depth)
    let done = term.done
    ann(type, expr, done)

normalize(term: Hoas, defs: Defs) : Hoas
  case term
  | typx =>
    typx
  | varx =>
    varx(term.indx)
  | refx =>
    let name = term.name
    let eras = term.eras
    case lookup(_ string_to_bits(name), defs) as got
    | none => refx(name, eras)
    | some => case got.value |def
      term_to_hoas(got.value.term, [])
  | allx =>
    let name = term.name
    let bind = normalize(term.bind, defs)
    let body = (x) => normalize(term.body(x), defs)
    let eras = term.eras
    allx(name, bind, body, eras)
  | lamx =>
    let name = term.name
    let body = (x) => normalize(term.body(x), defs)
    let eras = term.eras
    lamx(name, body, eras)
  | appx =>
    case unit with normalize(term.func, defs) as func : Hoas |unit
    case func
    with term.argm : Hoas
    with term.eras : Bool
    | typx => appx(func, normalize(term.argm, defs), term.eras)
    | varx => appx(func, normalize(term.argm, defs), term.eras)
    | refx => appx(func, normalize(term.argm, defs), term.eras)
    | allx => appx(func, normalize(term.argm, defs), term.eras)
    | lamx => normalize(func.body(term.argm), defs)
    | appx => appx(func, normalize(term.argm, defs), term.eras)
    | slfx => appx(func, normalize(term.argm, defs), term.eras)
    | insx => appx(func, normalize(term.argm, defs), term.eras)
    | elix => appx(func, normalize(term.argm, defs), term.eras)
    | annx => appx(func, normalize(term.argm, defs), term.eras)
  | slfx =>
    let name = term.name
    let type = (x) => normalize(term.type(x), defs)
    slfx(name, type)
  | insx =>
    let type = normalize(term.type, defs)
    let expr = normalize(term.expr, defs)
    insx(type, expr)
  | elix =>
    case unit with normalize(term.expr, defs) as expr : Hoas |unit
    case expr
    | typx => elix(expr)
    | varx => elix(expr)
    | refx => elix(expr)
    | allx => elix(expr)
    | lamx => elix(expr)
    | appx => elix(expr)
    | slfx => elix(expr)
    | insx => elix(expr)
    | elix => expr
    | annx => elix(expr)
  | annx =>
    let type = normalize(term.type, defs)
    let expr = normalize(term.expr, defs)
    let done = term.done
    annx(type, expr, done)

reduce(term: Term, defs: Defs) : Term
  hoas_to_term(normalize(term_to_hoas(term, []), defs), 0n)

// :::::::::::::::::
// :: Stringifier ::
// :::::::::::::::::

show.go(term: Term, names: List(String)) : Concat(Char)
  case term
  | typ =>
    let type = list_to_concat(Char; "Type")
    (x) => type(x)
  | var =>
    (x) => case at(String; term.indx, names) as got
      | none =>
        let numb = nat_to_number(term.indx)
        let str0 = list_to_concat(Char; "#")
        let str1 = list_to_concat(Char; number_to_string(10, numb))
        str0(str1(x))
      | some =>
        list_to_concat(Char; got.value, x)
  | ref =>
    let name = list_to_concat(Char; term.name)
    (x) => name(x)
  | all =>
    let pun0 = list_to_concat(Char; "(")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; " : ")
    let bind = show.go(term.bind, names)
    let pun2 = list_to_concat(Char; ") -> ")
    let body = show.go(term.body, cons(String; term.name, names))
    (x) => pun0(name(pun1(bind(pun2(body(x))))))
  | lam =>
    let pun0 = list_to_concat(Char; "(")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; ") => ")
    let body = show.go(term.body, cons(String; term.name, names))
    (x) => pun0(name(pun1(body(x))))
  | app =>
    let pun0 = list_to_concat(Char; "(")
    let func = show.go(term.func, names)
    let pun1 = list_to_concat(Char; ")(")
    let argm = show.go(term.argm, names)
    let pun2 = list_to_concat(Char; ")")
    (x) => pun0(func(pun1(argm(pun2(x)))))
  | slf =>
    let pun0 = list_to_concat(Char; "type{")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; "} ")
    //let type = show.go(term.type, names)
    let type = show.go(term.type, cons(String; term.name, names))
    (x) => pun0(name(pun1(type(x))))
  | ins =>
    let pun0 = list_to_concat(Char; "inst{")
    let type = show.go(term.type, names)
    let pun1 = list_to_concat(Char; "}");
    let expr = show.go(term.expr, names)
    (x) => pun0(type(pun1(expr(x))))
  | eli =>
    let pun0 = list_to_concat(Char; "elim{")
    let expr = show.go(term.expr, names)
    let pun1 = list_to_concat(Char; "}")
    (x) => pun0(expr(pun1(x)))
  | ann =>
    let type = show.go(term.type, names)
    let pun0 = list_to_concat(Char; " :: ")
    let expr = show.go(term.expr, names)
    (x) => type(pun0(expr(x)))
  : Concat(Char)
  
show(term: Term) : String
  show.go(term, [], [])

//show_defs.go(defs: Defs) : String
  //let els = map_elements(_ defs)
  //let cons = (term, str) =>
    //let name = list_to_concat(Char; show(head))
    //let 
  //fold(Def; String; 
  //| none => nil(_)
  //| some => 
  //case defs
  //| none => nil(_)
  //| some => case 
  
// ::::::::::::
// :: Parser ::
// ::::::::::::

// The parser below would be prettier with monads, but it
// avoids that in order to increase performance to the
// theoretical maximum, and decrease the dependency.

Parsed : Type
  Maybe(Pair(String, Term))

Vars : Type
  List(String)

// If `b` is successful, return it. Otherwise, try `a`.
try(a: Lazy(Parsed), b: Parsed) : Parsed
  case b
  with unit : Unit
  |none case force(_ a) as a
    |none none(_)
    |some some(_ a.value)
  |some some(_ b.value)

// Drops some characters from code
drop(amount: Nat, code: String) : String
  case amount |zero code |succ
  case code   |nil  code |cons
  drop(amount.pred, code.tail)

// Is this character allowed in names?
is_name_char(chr: Char) : Number
  ((chr > 47) && (chr < 58))  || // 0-9
  ((chr > 64) && (chr < 91))  || // A-Z 
  ((chr > 96) && (chr < 123)) || // a-z
  (chr === 95)                   // _ 

// Is this character a space?
is_space_char(chr: Char) : Number
  (chr === ' ') || (chr === 10)

// Removes leadig spaces
skip_spaces(code: String) : String
  case code |nil nil(_) |cons
  if is_space_char(code.head) then
    skip_spaces(code.tail)
  else
    code

// Are there non-space characters on this line?
line_has_chars(code: String) : Number
  case code |nil 0 |cons
  if (code.head === ' ') then
    line_has_chars(code.tail)
  else if (code.head === 10) then
    0
  else
    1

// Matches an exact string, returns the remaining code
consume(value: String, code: String) : Maybe(String)
  let code = skip_spaces(code)
  case value |nil some(_ code) |cons
  case code  |nil none(_)      |cons
  if code.head === value.head then
    consume(value.tail, code.tail)
  else
    none(_)

// Parses name characters
parse_name.go(code: String) : Pair(String, String)
  case code |nil #[code, nil(_)] |cons
  if is_name_char(code.head) then
    get #[code, name] = parse_name.go(code.tail)
    #[code, cons(Char; code.head, name)]
  else
    #[code, nil(Char;)]

parse_name(code: String) : Pair(String, String)
  parse_name.go(skip_spaces(code))

// Parses a grouping `(...)`
parse_grp(code: String, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses term
  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,term] = got.value

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  some(_ pair(__ code, term))

// Parses `(x:A)->B`
parse_all(code: String, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses variable name
  get #[code, name] = parse_name(code)

  // Parses `:`
  case consume(":",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses variable type
  case parse_term(code, vars) as got
  |none => none(_)
  |some => get #[code, type] = got.value

  // Parses erasure
  get #[code,eras] =
    case consume(";",code) as got
    |none => #[code, false]
    |some => #[got.value, true]

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses `->`
  case consume("->",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses body
  case parse_term(code, cons(_ name, vars)) as got
  |none => none(_)
  |some => get #[code, body] = got.value

  // Result
  some(_ pair(__ code, all(name, type, body, eras)))

// Parses `(x:A)=>B`
parse_lam(code: String, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses variable name
  get #[code, name] = parse_name(code)

  // Parses erasure
  get #[code,eras] =
    case consume(";",code) as got
    |none => #[code, false]
    |some => #[got.value, true]

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses `->`
  case consume("=>",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses body
  case parse_term(code, cons(_ name, vars)) as got
  |none => none(_)
  |some => get #[code, body] = got.value

  // Result
  some(_ pair(__ code, lam(name, body, eras)))

// Parses `Type`
parse_typ(code: String, vars: Vars) : Parsed
  case consume("Type",code) as got
  |none => none(_)
  |some => some(_ pair(__ got.value, typ))

// Parses variables
parse_var(code: String, vars: Vars) : Parsed
  get #[code,name] = parse_name(code)
  case find_index(_ string.equal(name), vars) as found
  |none =>
    case name |nil none(_) |cons
    some(_ pair(__ code, ref(name, false)))
  |some =>
    some(_ pair(__ code, var(found.value)))

// Parses a self type
parse_slf(code: String, vars: Vars) : Parsed
  case consume("type{",code) as got
  |none => none(_)
  |some => let code = got.value

  get #[code,name] = parse_name(code)

  case consume("}",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code, cons(_ name, vars)) as got
  |none => none(_)
  |some => get #[code,body] = got.value

  some(_ pair(__ code, slf(name, body)))

// Parses a self instantiation
parse_ins(code: String, vars: Vars) : Parsed
  case consume("inst{",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,type] = got.value

  case consume("}",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,expr] = got.value 

  some(_ pair(__ code, ins(type, expr)))

// Parses a self elimination
parse_eli(code: String, vars: Vars) : Parsed
  case consume("elim{",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,expr] = got.value

  some(_ pair(__ code, eli(expr)))

// Parses application
parse_app(code: String, func: Term, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses argument
  case parse_term(code, vars) as got
  |none => none(_)
  |some => get #[code,argm] = got.value

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  some(_ pair(__ code, app(func, argm, false)))

// Postfix parses
// Attempts each one repeatedly, until all fail
parse_postfix(code: String, term: Term, vars: Vars) : Parsed
  if line_has_chars(code) then
    let parsed = none(_)
    let parsed = try((x)=>parse_app(code, term, vars), parsed)
    case parsed
    |none some(_ pair(__ code, term))
    |some get #[code,term] = parsed.value
    parse_postfix(code, term, vars)
  else
    some(_ pair(__ code, term))

// Parses terms
parse_term(code: String, vars: Vars) : Parsed
  let parsed = none(_)
  let parsed = try((x)=>parse_all(code, vars), parsed)
  let parsed = try((x)=>parse_lam(code, vars), parsed)
  let parsed = try((x)=>parse_grp(code, vars), parsed)
  let parsed = try((x)=>parse_typ(code, vars), parsed)
  let parsed = try((x)=>parse_slf(code, vars), parsed)
  let parsed = try((x)=>parse_ins(code, vars), parsed)
  let parsed = try((x)=>parse_eli(code, vars), parsed)
  let parsed = try((x)=>parse_var(code, vars), parsed)
  case parsed |none none(_) |some
  get #[code, term] = parsed.value
  parse_postfix(code, term, vars)

// Parses defs
parse_defs.go(code: String, defs: Defs) : Defs
  get #[code,name] = parse_name(code)
  case name
  with defs : Defs
  | nil  => defs
  | cons =>
    let name = cons(_ name.head, name.tail)
    case consume(":",code) as got
    with defs : Defs
    |none => defs
    |some => let code = got.value
    case parse_term(code, []) as got
    with defs : Defs
    |none => defs
    |some => get #[code,type] = got.value
    case parse_term(code, []) as got
    with defs : Defs
    |none => defs
    |some => get #[code,term] = got.value
    let bits = string_to_bits(name)
    let defs = insert(_ bits, def(type,term), defs)
    parse_defs.go(code, defs)

// Parses defs
parse_defs(code: String) : Defs
  parse_defs.go(code, empty(_))

// ::::::::::::::
// :: Equality ::
// ::::::::::::::

identical(a: Term, b: Term) : Bool
  case a
  | typ =>
    case b
    | typ => true
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | var =>
    case b
    | typ => false
    | var => nat_equal(a.indx, b.indx) 
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | ref =>
    case b
    | typ => false
    | var => false
    | ref => string_equal(a.name,b.name)
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | all =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => and(equal(a.bind,b.bind),equal(a.body,b.body))
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | lam =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => and(equal(a.body,b.body))
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | app =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => and(equal(a.func,b.func),equal(a.argm,b.argm))
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | slf =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => equal(a.type,b.type)
    | ins => false
    | eli => false
    | ann => false
  | ins =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => and(equal(a.type,b.type),equal(a.expr,b.expr))
    | eli => false
    | ann => false
  | eli =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => equal(a.expr,b.expr)
    | ann => false
  | ann =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => equal(a.expr,b.expr)
  
// :::::::::::::::::::
// :: Type-Checking ::
// :::::::::::::::::::

Context : Type
  List(Term)

ctx.get(ctx: Context, i: Nat) : Maybe(Term)
  case at(_ i, ctx) as got
  | none => none(_) 
  | some => some(_ shift(got.value, succ(i), 0n))

ctx.nil : Context
  nil(_)

ctx.ext(ctx: Context, term: Term) : Context
  cons(_ term, ctx)

Equations : Type
  List(Pair(Term,Term))

// Type-checks a term
typecheck(
  term : Term,
  type : Maybe(Term),
  defs : Defs,
  ctx  : Context
) : Maybe(Pair(Equations, Term))
  // TODO: weak reduce intead
  let type = case type
    | none => none(_)
    | some => some(_reduce(type.value,defs))

  let chk = case term

    // Type of Types
    | typ =>
      some(_ pair(__ [], typ))

    // Variables
    | var =>
      case ctx.get(ctx, term.indx) as got
      | none => none(_)
      | some => some(_ pair(__ [], got.value))

    // Reference
    | ref => 
      case lookup(_ string_to_bits(term.name), defs) as got
      | none =>
        none(_)
      | some =>
        case got.value |def
        some(_ pair(__ [], got.value.type))

    // Function Type (Universal Quantification)
    | all =>
      let bind_chk = typecheck(term.bind, some(_ typ), defs, ctx)
      let ext_ctx  = ctx.ext(ctx, term.bind)
      let body_chk = typecheck(term.body, some(_ typ), defs, ext_ctx)
      case bind_chk
      | none => none(_)
      | some => get #[bind_eqs, bind_typ] = bind_chk.value
      case body_chk
      | none => none(_)
      | some => get #[body_eqs, body_typ] = body_chk.value
      let term_eqs = concat(_ bind_eqs, body_eqs)
      let term_typ = typ
      some(_ pair(__ term_eqs, term_typ))

    // Function Value (Lambda)
    | lam =>
      case type
      | none => none(_)
      | some => case type.value as type
      | typ => none(_)
      | var => none(_)
      | ref => none(_)
      | all =>
        let ext_ctx  = ctx.ext(ctx, type.bind)
        let body_chk = typecheck(term.body, some(_ type.body), defs, ext_ctx)
        case body_chk
        | none => none(_)
        | some => get #[body_eqs, body_typ] = body_chk.value
        let term_eqs = body_eqs
        let term_typ = all(term.name, type.bind, body_typ, term.eras)
        some(_ pair(__ term_eqs, term_typ))
      | lam => none(_)
      | app => none(_)
      | slf => none(_)
      | ins => none(_)
      | eli => none(_)
      | ann => none(_)

    // Function Elimination (application)
    | app =>
      let func_chk = typecheck(term.func, none(_), defs, ctx)
      case func_chk
      | none => none(_)
      | some => get #[func_eqs, func_typ] = func_chk.value
      case func_typ
      | typ => none(_)
      | var => none(_)
      | ref => none(_)
      | all =>
        let argm_chk = typecheck(term.argm, some(_ func_typ.bind), defs, ctx)
        case argm_chk
        | none => none(_)
        | some => get #[argm_eqs, argm_typ] = argm_chk.value
        let term_eqs = concat(_ func_eqs, argm_eqs)
        let term_typ = subst(func_typ.body, term.argm, 0n)
        some(_ pair(__ term_eqs, term_typ))
      | lam => none(_)
      | app => none(_)
      | slf => none(_)
      | ins => none(_)
      | eli => none(_)
      | ann => none(_)

    // Self Type
    | slf => none(_)

    // Self Value
    | ins => none(_)

    // Self Elimination
    | eli => none(_)

    // Annotation
    | ann => some(_ pair(__ [], term.type))

  // Appends expected/inferred type to equations list
  case chk
  | none => none(_)
  | some => get #[term_eqs, term_typ] = chk.value
  let cons_eqs = 
    case type
    | none => (x) => x
    | some => (x) => cons(_ pair(__ type.value, term_typ), x)
    : Equations -> Equations
  let term_eqs = cons_eqs(term_eqs)

  // Return equations list and inferred type
  some(_ pair(__ term_eqs, term_typ))

show_equations.go(eqs: Equations) : Concat(Char)
  case eqs
  |nil =>
    (x: List(Char)) => x
  |cons =>
    case eqs.head |pair
    let s0 = list_to_concat(Char; "A== ")
    let s1 = show.go(eqs.head.fst, [])
    let s2 = list_to_concat(Char; [10])
    let s3 = list_to_concat(Char; "B== ")
    let s4 = show.go(eqs.head.snd, [])
    let s5 = list_to_concat(Char; [10])
    let s6 = show_equations.go(eqs.tail)
    (x: List(Char)) => s0(s1(s2(s3(s4(s5(s6(x)))))))

show_equations(eqs: Equations) : String
  show_equations.go(eqs, [])

// ::::::::::
// :: Test ::
// ::::::::::

main
  let defs = parse_defs("
    Nat : Type
      (A: Type) -> (z : A) -> (s : (x:A) -> A) -> A
      
    zero : (A: Type) -> (z : A) -> (s : (x:A) -> A) -> A
      (A) => (z) => (s) => z

    succ : (n : Nat) -> Nat
      (n) => (A) => (z) => (s) => s(n(A)(z)(s))

    mul : (a : Nat) -> (b : Nat) -> Nat
      (a) => (b) => (A) => (z) => (s) => a(A)(z)((x) => b(A)(x)(s))

    main : Nat
      mul(succ(succ(zero)))(succ(succ(zero)))
  ")

  case lookup(_ string_to_bits("main"), defs) as got
  | none => print("Def not found.")
  | some => case got.value |def do {
    let type = got.value.type
    let term = got.value.term

    case typecheck(term, some(_ type), defs, []) as term_t
    | none => do {
      print("Type error.")
      print(show(term))
      print(show(reduce(term,defs)))
    }
    | some => case term_t.value |pair do {
      print("[Term]")
      print(show(term))
      print("")
      print("[Norm]")
      print(show(reduce(term,defs)))
      print("")
      print("[Type]")
      print(show(term_t.value.snd))
      print("")
      print("[Equations]")
      print(show_equations(term_t.value.fst))
    }
  }
