// A ideia é que o Formality-Lang compila para o
// Formality-Core para fins de type-checking apenas. O
// Formality-Lang tem coisas tipo ADTs e números, enquanto o
// Formality-Core só tem lambdas e self. Para virar
// JavaScript, a compilação parte do Formality-Lang, de modo
// a poder usar os números e ADTs nele presentes.

import Bits
import IO
import Map
import Nat
import Number
import String
import Unit
import Parse
import NonEmpty


// ::::::::::
// :: Term ::
// ::::::::::

T Term
| typ
| var(indx: Nat)
| ref(name: String, eras: Bool)
| all(name: String, bind: Term, body: Term, eras: Bool)
| lam(name: String, body: Term, eras: Bool)
| app(func: Term, argm: Term, eras: Bool)
| slf(name: String, type: Term)
| ins(type: Term, expr: Term)
| eli(expr: Term)
| ann(type: Term, expr: Term, done: Bool)
  
T Def
| def(type: Term, term: Term)

Defs : Type
  Map(Def)

// ::::::::::::::::::
// :: Substitution ::
// ::::::::::::::::::

shift(term: Term, inc: Nat, dep: Nat) : Term
  case term
  | typ =>
    typ
  | var =>
    case nat_compare(term.indx, dep) as cmp
    | less_than    => var(term.indx)
    | equal_to     => var(add(inc, term.indx))
    | greater_than => var(add(inc, term.indx))
  | ref =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)
  | all =>
    let name = term.name
    let bind = shift(term.bind, inc, dep)
    let body = shift(term.body, inc, succ(dep))
    let eras = term.eras
    all(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = shift(term.body, inc, succ(dep))
    let eras = term.eras
    lam(name, body, eras)
  | app =>
    let func = shift(term.func, inc, dep)
    let argm = shift(term.argm, inc, dep)
    let eras = term.eras
    app(func, argm, eras)
  | slf =>
    let name = term.name
    let type = shift(term.type, inc, succ(dep))
    slf(name, type)
  | ins =>
    let type = shift(term.type, inc, dep)
    let expr = shift(term.expr, inc, dep)
    ins(type, expr)
  | eli =>
    let expr = shift(term.expr, inc, dep)
    eli(expr)
  | ann =>
    let type = shift(term.type, inc, dep)
    let expr = shift(term.expr, inc, dep)
    let done = term.done
    ann(type, expr, done)

subst(term: Term, trm: Term, dep: Nat) : Term
  case term
  | typ =>
    typ
  | var =>
    case nat_compare(term.indx, dep) as cmp
    | less_than    => var(term.indx)
    | equal_to     => trm
    | greater_than => var(pred(term.indx))
  | ref =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)
  | all =>
    let name = term.name
    let bind = subst(term.bind, trm, dep)
    let body = subst(term.body, shift(trm,1n,0n), succ(dep))
    let eras = term.eras
    all(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = subst(term.body, shift(trm,1n,0n), succ(dep))
    let eras = term.eras
    lam(name, body, eras)
  | app =>
    let func = subst(term.func, trm, dep)
    let argm = subst(term.argm, trm, dep)
    let eras = term.eras
    app(func, argm, eras)
  | slf =>
    let name = term.name
    let type = subst(term.type, shift(trm,1n,0n), succ(dep))
    slf(name, type)
  | ins =>
    let type = subst(term.type, trm, dep)
    let expr = subst(term.expr, trm, dep)
    ins(type, expr)
  | eli =>
    let expr = subst(term.expr, trm, dep)
    eli(expr)
  | ann =>
    let type = subst(term.type, trm, dep)
    let expr = subst(term.expr, trm, dep)
    let done = term.done
    ann(type, expr, done)

subst_many(term: Term, vals: List(Term), inc: Nat, dep: Nat) : Term
  case vals
  | nil =>
    term
  | cons =>
    let sval = shift(vals.head, inc, 0n)
    let sdep = add(dep, inc)
    let term = subst(term, sval, sdep)
    subst_many(term, vals.tail, pred(inc), dep)

// :::::::::::::::::::
// :: Normalization ::
// :::::::::::::::::::

T Hoas
| typx
| varx(indx: Nat)
| refx(name: String, eras: Bool)
| allx(name: String, bind: Hoas, body: Hoas -> Hoas, eras: Bool)
| lamx(name: String, body: Hoas -> Hoas, eras: Bool)
| appx(func: Hoas, argm: Hoas, eras: Bool)
| slfx(name: String, type: Hoas -> Hoas)
| insx(type: Hoas, expr: Hoas)
| elix(expr: Hoas)
| annx(type: Hoas, expr: Hoas, done: Bool)

term_to_hoas(term: Term, vals: List(Hoas)) : Hoas
  case term
  | typ =>
    typx
  | var =>
    case at(Hoas; term.indx, vals) as got
    | none => varx(term.indx)
    | some => got.value
  | ref =>
    let name = term.name
    let eras = term.eras
    refx(name, eras)
  | all =>
    let name = term.name
    let bind = term_to_hoas(term.bind, vals)
    let body = (x) => term_to_hoas(term.body,cons(_ x,vals))
    let eras = term.eras
    allx(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = (x) => term_to_hoas(term.body,cons(_ x,vals))
    let eras = term.eras
    lamx(name, body, eras)
  | app =>
    let func = term_to_hoas(term.func, vals)
    let argm = term_to_hoas(term.argm, vals)
    let eras = term.eras
    appx(func, argm, eras)
  | slf =>
    let name = term.name
    let type = (x) => term_to_hoas(term.type, cons(_ x, vals))
    slfx(name, type)
  | ins =>
    let type = term_to_hoas(term.type, vals)
    let expr = term_to_hoas(term.expr, vals)
    insx(type, expr)
  | eli =>
    let expr = term_to_hoas(term.expr, vals)
    elix(expr)
  | ann =>
    let type = term_to_hoas(term.type, vals)
    let expr = term_to_hoas(term.expr, vals)
    let done = term.done
    annx(type, expr, done)

hoas_to_term(term: Hoas, depth: Nat) : Term
  case term
  | typx =>
    typ
  | varx =>
    case nat_compare(term.indx, depth) as cmp
    | less_than    => var(sub(depth, succ(term.indx)))
    | equal_to     => var(term.indx)
    | greater_than => var(term.indx)
  | refx =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)
  | allx =>
    let name = term.name
    let bind = hoas_to_term(term.bind, depth)
    let body = hoas_to_term(term.body(varx(depth)), succ(depth))
    let eras = term.eras
    all(name, bind, body, eras)
  | lamx =>
    let name = term.name
    let body = hoas_to_term(term.body(varx(depth)), succ(depth))
    let eras = term.eras
    lam(name, body, eras)
  | appx =>
    let func = hoas_to_term(term.func, depth)
    let argm = hoas_to_term(term.argm, depth)
    let eras = term.eras
    app(func, argm, eras)
  | slfx =>
    let name = term.name
    let type = hoas_to_term(term.type(varx(depth)), succ(depth))
    slf(name, type)
  | insx =>
    let type = hoas_to_term(term.type, depth)
    let expr = hoas_to_term(term.expr, depth)
    ins(type, expr)
  | elix =>
    let expr = hoas_to_term(term.expr, depth)
    eli(expr)
  | annx =>
    let type = hoas_to_term(term.type, depth)
    let expr = hoas_to_term(term.expr, depth)
    let done = term.done
    ann(type, expr, done)

normalize(term: Hoas, defs: Defs) : Hoas
  case term
  | typx =>
    typx
  | varx =>
    varx(term.indx)
  | refx =>
    let name = term.name
    let eras = term.eras
    case lookup(_ string_to_bits(name), defs) as got
    | none => refx(name, eras)
    | some => case got.value |def
      term_to_hoas(got.value.term, [])
  | allx =>
    let name = term.name
    let bind = normalize(term.bind, defs)
    let body = (x) => normalize(term.body(x), defs)
    let eras = term.eras
    allx(name, bind, body, eras)
  | lamx =>
    let name = term.name
    let body = (x) => normalize(term.body(x), defs)
    let eras = term.eras
    lamx(name, body, eras)
  | appx =>
    case unit with normalize(term.func, defs) as func : Hoas |unit
    case func
    with term.argm : Hoas
    with term.eras : Bool
    | typx => appx(func, normalize(term.argm, defs), term.eras)
    | varx => appx(func, normalize(term.argm, defs), term.eras)
    | refx => appx(func, normalize(term.argm, defs), term.eras)
    | allx => appx(func, normalize(term.argm, defs), term.eras)
    | lamx => normalize(func.body(term.argm), defs)
    | appx => appx(func, normalize(term.argm, defs), term.eras)
    | slfx => appx(func, normalize(term.argm, defs), term.eras)
    | insx => appx(func, normalize(term.argm, defs), term.eras)
    | elix => appx(func, normalize(term.argm, defs), term.eras)
    | annx => appx(func, normalize(term.argm, defs), term.eras)
  | slfx =>
    let name = term.name
    let type = (x) => normalize(term.type(x), defs)
    slfx(name, type)
  | insx =>
    let type = normalize(term.type, defs)
    let expr = normalize(term.expr, defs)
    insx(type, expr)
  | elix =>
    case unit with normalize(term.expr, defs) as expr : Hoas |unit
    case expr
    | typx => elix(expr)
    | varx => elix(expr)
    | refx => elix(expr)
    | allx => elix(expr)
    | lamx => elix(expr)
    | appx => elix(expr)
    | slfx => elix(expr)
    | insx => elix(expr)
    | elix => expr
    | annx => elix(expr)
  | annx =>
    let type = normalize(term.type, defs)
    let expr = normalize(term.expr, defs)
    let done = term.done
    annx(type, expr, done)

reduce(term: Term, defs: Defs) : Term
  hoas_to_term(normalize(term_to_hoas(term, []), defs), 0n)

// :::::::::::::::::
// :: Stringifier ::
// :::::::::::::::::

show.go(term: Term, names: List(String)) : Concat(Char)
  case term
  | typ =>
    let type = list_to_concat(Char; "Type")
    (x) => type(x)
  | var =>
    (x) => case at(String; term.indx, names) as got
      | none =>
        let numb = nat_to_number(term.indx)
        let str0 = list_to_concat(Char; "#")
        let str1 = list_to_concat(Char; number_to_string(10, numb))
        str0(str1(x))
      | some =>
        list_to_concat(Char; got.value, x)
  | ref =>
    let name = list_to_concat(Char; term.name)
    (x) => name(x)
  | all =>
    let pun0 = list_to_concat(Char; "(")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; " : ")
    let bind = show.go(term.bind, names)
    let pun2 = list_to_concat(Char; ") -> ")
    let body = show.go(term.body, cons(String; term.name, names))
    (x) => pun0(name(pun1(bind(pun2(body(x))))))
  | lam =>
    let pun0 = list_to_concat(Char; "(")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; ") => ")
    let body = show.go(term.body, cons(String; term.name, names))
    (x) => pun0(name(pun1(body(x))))
  | app =>
    let pun0 = list_to_concat(Char; "(")
    let func = show.go(term.func, names)
    let pun1 = list_to_concat(Char; ")(")
    let argm = show.go(term.argm, names)
    let pun2 = list_to_concat(Char; ")")
    (x) => pun0(func(pun1(argm(pun2(x)))))
  | slf =>
    let pun0 = list_to_concat(Char; "type{")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; "} ")
    //let type = show.go(term.type, names)
    let type = show.go(term.type, cons(String; term.name, names))
    (x) => pun0(name(pun1(type(x))))
  | ins =>
    let pun0 = list_to_concat(Char; "inst{")
    let type = show.go(term.type, names)
    let pun1 = list_to_concat(Char; "}");
    let expr = show.go(term.expr, names)
    (x) => pun0(type(pun1(expr(x))))
  | eli =>
    let pun0 = list_to_concat(Char; "elim{")
    let expr = show.go(term.expr, names)
    let pun1 = list_to_concat(Char; "}")
    (x) => pun0(expr(pun1(x)))
  | ann =>
    let type = show.go(term.type, names)
    let pun0 = list_to_concat(Char; " :: ")
    let expr = show.go(term.expr, names)
    (x) => type(pun0(expr(x)))
  : Concat(Char)
  
show(term: Term) : String
  show.go(term, [], [])

//show_defs.go(defs: Defs) : String
  //let els = map_elements(_ defs)
  //let cons = (term, str) =>
    //let name = list_to_concat(Char; show(head))
    //let 
  //fold(Def; String; 
  //| none => nil(_)
  //| some => 
  //case defs
  //| none => nil(_)
  //| some => case 

// ::::::::::::
// :: Parser ::
// ::::::::::::

T FPErr
| fp_err

FParsed(A) : Type; Parsed(FPErr, A)
FParser(A) : Type; Parser(FPErr, A)

Vars : Type
  List(String)

// Is this character a space?
is_space_char(chr: Char) : Number
  (chr === ' ') || (chr === 10)

// Removes leadig spaces
whitespace : FParser(String)
  p_take_while(_ is_space_char)

// alphabetic character
alpha_char(chr: Char) : Number
  ((chr > 64) && (chr < 91))  || // A-Z
  ((chr > 96) && (chr < 123))    // a-z

// Is this character allowed in names?
name_char(chr: Char) : Number
  ((chr > 47) && (chr < 58))  || // 0-9
  ((chr > 64) && (chr < 91))  || // A-Z 
  ((chr > 96) && (chr < 123)) || // a-z
  (chr === 95)                   // _

parse_name : FParser(String)
  p_bind(___ p_take_while(_ (x) => x === 95), (x1) =>
     case x1
     | nil
        p_bind(___ p_satisfy(_ alpha_char), (x2) =>
        p_bind(___ p_take_while(_ name_char), (x3) =>
        p_pure(__ cons(_ x2,x3))))
     | cons
        p_bind(___ p_many1(__ p_satisfy(_ name_char)),(x3) =>
        p_pure(__ concat(_ x1, ne_to_list(_ x3))))
    )

parse_refVar(vars : Vars): FParser(Term)
  p_bind(___ parse_name, (nam) =>
    case find_index(_ string.equal(nam), vars) as found
    |none => p_pure(__ ref(nam, false))
    |some => p_pure(__ var(found.value))
    )

p_symbol(x : String) : FParser(String)
  p_seqr(___ p_string(_ x), whitespace)

parse_all(vars : Vars) : FParser(Term)
  p_seql(___ p_symbol("("),
  p_bind(___ parse_name, (nam) =>
  p_seql(___ whitespace,
  p_seql(___ p_symbol(":"),
  p_bind(___ parse_term(vars), (typ) =>
  p_bind(___ p_optional(__ p_string(_ ";")), (era) =>
  p_seql(___ whitespace,
  p_seql(___ p_symbol(")"),
  p_seql(___ p_symbol("->"),
  p_bind(___ parse_term(cons(_ nam, vars)), (bod) =>
  p_pure(__ 
    case era
    |none all(nam,typ,bod,false)
    |some all(nam,typ,bod,true)
  )))))))))))

parse_lam(vars : Vars) : FParser(Term)
  p_seql(___ p_symbol("("),
  p_bind(___ parse_name, (nam) =>
  p_bind(___ p_optional(__ p_string(_ ";")), (era) =>
  p_seql(___ whitespace,
  p_seql(___ p_symbol(")"),
  p_seql(___ p_symbol("=>"),
  p_bind(___ parse_term(cons(_ nam, vars)), (bod) =>
  p_pure(__
    case era
    |none lam(nam,bod,false)
    |some lam(nam,bod,true)
  ))))))))

parse_grp(vars : Vars) : FParser(Term)
  p_seql(___ p_symbol("("),
  p_bind(___ parse_term(vars), (ter) =>
  p_seql(___ whitespace,
  p_seql(___ p_string(_ ")"),
  p_pure(__ ter)
  ))))

parse_slf(vars: Vars) : FParser(Term)
  p_seql(___ p_symbol("type{"),
  p_bind(___ parse_name, (nam) =>
  p_seql(___ whitespace,
  p_seql(___ p_symbol("}"),
  p_bind(___ parse_term(cons(_ nam, vars)), (bod) =>
  p_pure(__ slf(nam,bod))
  )))))

parse_ins(vars: Vars) : FParser(Term)
  p_seql(___ p_symbol("inst{"),
  p_bind(___ parse_term(vars), (typ) =>
  p_seql(___ whitespace,
  p_seql(___ p_symbol("}"),
  p_bind(___ parse_term(vars), (bod) =>
  p_pure(__  ins(typ,bod))
  )))))

parse_eli(vars: Vars) : FParser(Term)
  p_seql(___ p_symbol("elim{"),
  p_bind(___ parse_term(vars), (exp) =>
  p_seql(___ whitespace,
  p_seql(___ p_string(_ "}"),
  p_pure(__  eli(exp))
  ))))

parse_term.go(vars : Vars) : FParser(Term)
  p_choice(__
  [ parse_all(vars),
    parse_lam(vars),
    p_seql(___ p_string(_ "Type"),p_pure(__ typ)),
    parse_slf(vars),
    parse_ins(vars),
    parse_eli(vars),
    parse_refVar(vars),
    parse_grp(vars),
  ])

parse_app(fun: Term, vars: Vars) : FParser(Term)
  p_seql(___ p_symbol("("),
  p_bind(___ parse_term(vars), (arg) =>
  p_bind(___ p_optional(__ p_string(_ ";")), (era) =>
  p_seql(___ whitespace,
  p_seql(___ p_string(_ ")"),
  p_pure(__
    case era
    |none app(fun,arg,false)
    |some app(fun,arg,true)
  ))))))

parse_ann(ter: Term, vars: Vars) : FParser(Term)
  p_seql(___ whitespace,
  p_seql(___ p_symbol("::"),
  p_bind(___ parse_term(vars), (typ) =>
  p_pure(__ ann(typ,ter,false))
  )))

parse_term(vars : Vars) : FParser(Term)
  p_bind(___ parse_term.go(vars), (t) =>
  p_choice(__
  [ parse_app(t,vars),
    parse_ann(t,vars),
    p_pure(__ t)
  ]
  ))

parse_def : FParser(Pair(String,Def))
  p_bind(___ parse_name, (nam) =>
  p_seql(___ whitespace,
  p_seql(___ p_symbol(":"),
  p_bind(___ parse_term([]), (typ) =>
  p_seql(___ whitespace,
  p_bind(___ parse_term([]), (ter) =>
  p_pure(__ pair(__ nam,def(typ,ter)))
  ))))))

parse_defs.go(defs : Defs) : FParser(Defs)
  p_bind(___ parse_def, (x) =>
  p_seql(___ whitespace,
  get #[n,d] = x;
  let bits = string_to_bits(n)
  let defs = insert(_ bits, d, defs)
  p_choice(__
  [ p_seql(___ p_eof(_), p_pure(__ defs)), 
  parse_defs.go(defs)
  ])
  ))

parse_defs : FParser(Defs)
  p_seql(___ whitespace, parse_defs.go(empty(_)))

// ::::::::::::::
// :: Equality ::
// ::::::::::::::

eq(a: Term, b: Term) : Bool
  case a
  | typ =>
    case b
    | typ => true
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | var =>
    case b
    | typ => false
    | var => nat_equal(a.indx, b.indx)
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | ref =>
    case b
    | typ => false
    | var => false
    | ref => string.equal(a.name,b.name)
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | all =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => and(eq(a.bind,b.bind),eq(a.body,b.body))
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | lam =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => eq(a.body,b.body)
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | app =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => and(eq(a.func,b.func),eq(a.argm,b.argm))
    | slf => false
    | ins => false
    | eli => false
    | ann => false
  | slf =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => eq(a.type,b.type)
    | ins => false
    | eli => false
    | ann => false
  | ins =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => and(eq(a.type,b.type),eq(a.expr,b.expr))
    | eli => false
    | ann => false
  | eli =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => eq(a.expr,b.expr)
    | ann => false
  | ann =>
    case b
    | typ => false
    | var => false
    | ref => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => eq(a.expr,b.expr)
  
// :::::::::::::::::::
// :: Type-Checking ::
// :::::::::::::::::::

Context : Type
  List(Term)

ctx.get(ctx: Context, i: Nat) : Maybe(Term)
  case at(_ i, ctx) as got
  | none => none(_) 
  | some => some(_ shift(got.value, succ(i), 0n))

ctx.nil : Context
  nil(_)

ctx.ext(ctx: Context, term: Term) : Context
  cons(_ term, ctx)

Equations : Type
  List(Pair(Term,Term))

// Type-checks a term
typecheck(
  term : Term,
  type : Maybe(Term),
  defs : Defs,
  ctx  : Context
) : Maybe(Pair(Equations, Term))
  // TODO: weak reduce intead
  let type = case type
    | none => none(_)
    | some => some(_reduce(type.value,defs))

  let chk = case term

    // Type of Types
    | typ =>
      some(_ pair(__ [], typ))

    // Variables
    | var =>
      case ctx.get(ctx, term.indx) as got
      | none => none(_)
      | some => some(_ pair(__ [], got.value))

    // Reference
    | ref => 
      case lookup(_ string_to_bits(term.name), defs) as got
      | none =>
        none(_)
      | some =>
        case got.value |def
        some(_ pair(__ [], got.value.type))

    // Function Type (Universal Quantification)
    | all =>
      let bind_chk = typecheck(term.bind, some(_ typ), defs, ctx)
      let ext_ctx  = ctx.ext(ctx, term.bind)
      let body_chk = typecheck(term.body, some(_ typ), defs, ext_ctx)
      case bind_chk
      | none => none(_)
      | some => get #[bind_eqs, bind_typ] = bind_chk.value
      case body_chk
      | none => none(_)
      | some => get #[body_eqs, body_typ] = body_chk.value
      let term_eqs = concat(_ bind_eqs, body_eqs)
      let term_typ = typ
      some(_ pair(__ term_eqs, term_typ))

    // Function Value (Lambda)
    | lam =>
      case type
      | none => none(_)
      | some => case type.value as type
      | typ => none(_)
      | var => none(_)
      | ref => none(_)
      | all =>
        let ext_ctx  = ctx.ext(ctx, type.bind)
        let body_chk = typecheck(term.body, some(_ type.body), defs, ext_ctx)
        case body_chk
        | none => none(_)
        | some => get #[body_eqs, body_typ] = body_chk.value
        let term_eqs = body_eqs
        let term_typ = all(term.name, type.bind, body_typ, term.eras)
        some(_ pair(__ term_eqs, term_typ))
      | lam => none(_)
      | app => none(_)
      | slf => none(_)
      | ins => none(_)
      | eli => none(_)
      | ann => none(_)

    // Function Elimination (application)
    | app =>
      let func_chk = typecheck(term.func, none(_), defs, ctx)
      case func_chk
      | none => none(_)
      | some => get #[func_eqs, func_typ] = func_chk.value
      case func_typ
      | typ => none(_)
      | var => none(_)
      | ref => none(_)
      | all =>
        let argm_chk = typecheck(term.argm, some(_ func_typ.bind), defs, ctx)
        case argm_chk
        | none => none(_)
        | some => get #[argm_eqs, argm_typ] = argm_chk.value
        let term_eqs = concat(_ func_eqs, argm_eqs)
        let term_typ = subst(func_typ.body, term.argm, 0n)
        some(_ pair(__ term_eqs, term_typ))
      | lam => none(_)
      | app => none(_)
      | slf => none(_)
      | ins => none(_)
      | eli => none(_)
      | ann => none(_)

    // Self Type
    | slf => none(_)

    // Self Value
    | ins => none(_)

    // Self Elimination
    | eli => none(_)

    // Annotation
    | ann => some(_ pair(__ [], term.type))

  // Appends expected/inferred type to equations list
  case chk
  | none => none(_)
  | some => get #[term_eqs, term_typ] = chk.value
  let cons_eqs = 
    case type
    | none => (x) => x
    | some => (x) => cons(_ pair(__ type.value, term_typ), x)
    : Equations -> Equations
  let term_eqs = cons_eqs(term_eqs)

  // Return equations list and inferred type
  some(_ pair(__ term_eqs, term_typ))

show_equations.go(eqs: Equations) : Concat(Char)
  case eqs
  |nil =>
    (x: List(Char)) => x
  |cons =>
    case eqs.head |pair
    let s0 = list_to_concat(Char; "A== ")
    let s1 = show.go(eqs.head.fst, [])
    let s2 = list_to_concat(Char; [10])
    let s3 = list_to_concat(Char; "B== ")
    let s4 = show.go(eqs.head.snd, [])
    let s5 = list_to_concat(Char; [10])
    let s6 = show_equations.go(eqs.tail)
    (x: List(Char)) => s0(s1(s2(s3(s4(s5(s6(x)))))))

show_equations(eqs: Equations) : String
  show_equations.go(eqs, [])

// ::::::::::
// :: Test ::
// ::::::::::

main : IO(Unit)
  let p = parse(__ parse_term([]), "Type")
  case p
  | p_err => print("Error")
  | p_res => print(show(p.res))



  -- case lookup(_ string_to_bits("main"), defs) as got
  -- | none => print("Def not found.")
  -- | some => case got.value |def do {
  --   let type = got.value.type
  --   let term = got.value.term

  --   case typecheck(term, some(_ type), defs, []) as term_t
  --   | none => do {
  --     print("Type error.")
  --     print(show(term))
  --     print(show(reduce(term,defs)))
  --   }
  --   | some => case term_t.value |pair do {
  --     print("[Term]")
  --     print(show(term))
  --     print("")
  --     print("[Norm]")
  --     print(show(reduce(term,defs)))
  --     print("")
  --     print("[Type]")
  --     print(show(term_t.value.snd))
  --     print("")
  --     print("[Equations]")
  --     print(show_equations(term_t.value.fst))
  --   }
  --}
