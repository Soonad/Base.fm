// A ideia é que o Formality-Lang compila para o
// Formality-Core para fins de type-checking apenas. O
// Formality-Lang tem coisas tipo ADTs e números, enquanto o
// Formality-Core só tem lambdas e self. Para virar
// JavaScript, a compilação parte do Formality-Lang, de modo
// a poder usar os números e ADTs nele presentes.

import Nat
import Unit
import String
import IO

// :::::::::::
// :: Utils ::
// :::::::::::

Lazy(A : Type) : Type
  Unit -> A

force(A; x: Lazy(A)) : A
  x(unit)

// ::::::::::
// :: Term ::
// ::::::::::

T Term
| var(indx: Nat)
| typ
| all(name: String, bind: Term, body: Term, eras: Bool)
| lam(name: String, body: Term, eras: Bool)
| app(func: Term, argm: Term, eras: Bool)
| slf(name: String, type: Term)
| ins(type: Term, expr: Term)
| eli(expr: Term)
| ann(type: Term, expr: Term, done: Bool)
| lgs(msge: Term, expr: Term)
| hol(name: String)
| ref(name: String, eras: Bool)

// ::::::::::::::::::
// :: Substitution ::
// ::::::::::::::::::

shift(term: Term, inc: Nat, dep: Nat) : Term
  case term
  | var =>
    case nat_compare(term.indx, dep) as cmp
    | less_than    => var(term.indx)
    | equal_to     => var(add(inc, term.indx))
    | greater_than => var(add(inc, term.indx))
  | typ =>
    typ
  | all =>
    let name = term.name
    let bind = shift(term.bind, inc, dep)
    let body = shift(term.body, inc, succ(dep))
    let eras = term.eras
    all(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = shift(term.body, inc, succ(dep))
    let eras = term.eras
    lam(name, body, eras)
  | app =>
    let func = shift(term.func, inc, dep)
    let argm = shift(term.argm, inc, dep)
    let eras = term.eras
    app(func, argm, eras)
  | slf =>
    let name = term.name
    let type = shift(term.type, inc, succ(dep))
    slf(name, type)
  | ins =>
    let type = shift(term.type, inc, dep)
    let expr = shift(term.expr, inc, dep)
    ins(type, expr)
  | eli =>
    let expr = shift(term.expr, inc, dep)
    eli(expr)
  | ann =>
    let type = shift(term.type, inc, dep)
    let expr = shift(term.expr, inc, dep)
    let done = term.done
    ann(type, expr, done)
  | lgs =>
    let msge = shift(term.msge, inc, dep)
    let expr = shift(term.expr, inc, dep)
    lgs(msge, expr)
  | hol =>
    let name = term.name
    hol(name)
  | ref =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)

subst(term: Term, trm: Term, dep: Nat) : Term
  case term
  | var =>
    case nat_compare(term.indx, dep) as cmp
    | less_than    => var(term.indx)
    | equal_to     => trm
    | greater_than => var(pred(term.indx))
  | typ =>
    typ
  | all =>
    let name = term.name
    let bind = subst(term.bind, trm, dep)
    let body = subst(term.body, trm, succ(dep))
    let eras = term.eras
    all(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = subst(term.body, shift(trm,1n,0n), succ(dep))
    let eras = term.eras
    lam(name, body, eras)
  | app =>
    let func = subst(term.func, trm, dep)
    let argm = subst(term.argm, shift(trm,1n,0n), dep)
    let eras = term.eras
    app(func, argm, eras)
  | slf =>
    let name = term.name
    let type = subst(term.type, shift(trm,1n,0n), succ(dep))
    slf(name, type)
  | ins =>
    let type = subst(term.type, trm, dep)
    let expr = subst(term.expr, trm, dep)
    ins(type, expr)
  | eli =>
    let expr = subst(term.expr, trm, dep)
    eli(expr)
  | ann =>
    let type = subst(term.type, trm, dep)
    let expr = subst(term.expr, trm, dep)
    let done = term.done
    ann(type, expr, done)
  | lgs =>
    let msge = subst(term.msge, trm, dep)
    let expr = subst(term.expr, trm, dep)
    lgs(msge, expr)
  | hol =>
    let name = term.name
    hol(name)
  | ref =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)

subst_many(term: Term, vals: List(Term), inc: Nat, dep: Nat) : Term
  case vals
  | nil =>
    term
  | cons =>
    let sval = shift(vals.head, inc, 0n)
    let sdep = add(dep, inc)
    let term = subst(term, sval, sdep)
    subst_many(term, vals.tail, pred(inc), dep)

// :::::::::::::::::::
// :: Normalization ::
// :::::::::::::::::::

T Hoas
| varx(indx: Nat)
| typx
| allx(name: String, bind: Hoas, body: Hoas -> Hoas, eras: Bool)
| lamx(name: String, body: Hoas -> Hoas, eras: Bool)
| appx(func: Hoas, argm: Hoas, eras: Bool)
| slfx(name: String, type: Hoas -> Hoas)
| insx(type: Hoas, expr: Hoas)
| elix(expr: Hoas)
| annx(type: Hoas, expr: Hoas, done: Bool)
| lgsx(msge: Hoas, expr: Hoas)
| holx(name: String)
| refx(name: String, eras: Bool)

term_to_hoas(term: Term, vals: List(Hoas)) : Hoas
  case term
  | var =>
    case at(Hoas; term.indx, vals) as got
    | none => varx(sub(length(_ vals), succ(term.indx)))
    | some => got.value
  | typ =>
    typx
  | all =>
    let name = term.name
    let bind = term_to_hoas(term.bind, vals)
    let body = (x) => term_to_hoas(term.body,cons(_ x,vals))
    let eras = term.eras
    allx(name, bind, body, eras)
  | lam =>
    let name = term.name
    let body = (x) => term_to_hoas(term.body,cons(_ x,vals))
    let eras = term.eras
    lamx(name, body, eras)
  | app =>
    let func = term_to_hoas(term.func, vals)
    let argm = term_to_hoas(term.argm, vals)
    let eras = term.eras
    appx(func, argm, eras)
  | slf =>
    let name = term.name
    let type = (x) => term_to_hoas(term.type, cons(_ x, vals))
    slfx(name, type)
  | ins =>
    let type = term_to_hoas(term.type, vals)
    let expr = term_to_hoas(term.expr, vals)
    insx(type, expr)
  | eli =>
    let expr = term_to_hoas(term.expr, vals)
    elix(expr)
  | ann =>
    let type = term_to_hoas(term.type, vals)
    let expr = term_to_hoas(term.expr, vals)
    let done = term.done
    annx(type, expr, done)
  | lgs =>
    let msge = term_to_hoas(term.msge, vals)
    let expr = term_to_hoas(term.expr, vals)
    lgsx(msge, expr)
  | hol =>
    let name = term.name
    holx(name)
  | ref =>
    let name = term.name
    let eras = term.eras
    refx(name, eras)

hoas_to_term(term: Hoas, depth: Nat) : Term
  case term
  | varx =>
    var(sub(depth, succ(term.indx)))
  | typx =>
    typ
  | allx =>
    let name = term.name
    let bind = hoas_to_term(term.bind, depth)
    let body = hoas_to_term(term.body(varx(depth)), succ(depth))
    let eras = term.eras
    all(name, bind, body, eras)
  | lamx =>
    let name = term.name
    let body = hoas_to_term(term.body(varx(depth)), succ(depth))
    let eras = term.eras
    lam(name, body, eras)
  | appx =>
    let func = hoas_to_term(term.func, depth)
    let argm = hoas_to_term(term.argm, depth)
    let eras = term.eras
    app(func, argm, eras)
  | slfx =>
    let name = term.name
    let type = hoas_to_term(term.type(varx(depth)), succ(depth))
    slf(name, type)
  | insx =>
    let type = hoas_to_term(term.type, depth)
    let expr = hoas_to_term(term.expr, depth)
    ins(type, expr)
  | elix =>
    let expr = hoas_to_term(term.expr, depth)
    eli(expr)
  | annx =>
    let type = hoas_to_term(term.type, depth)
    let expr = hoas_to_term(term.expr, depth)
    let done = term.done
    ann(type, expr, done)
  | lgsx =>
    let msge = hoas_to_term(term.msge, depth)
    let expr = hoas_to_term(term.expr, depth)
    lgs(msge, expr)
  | holx =>
    let name = term.name
    hol(name)
  | refx =>
    let name = term.name
    let eras = term.eras
    ref(name, eras)

normalize(term: Hoas) : Hoas
  case term
  | varx =>
    varx(term.indx)
  | typx =>
    typx
  | allx =>
    let name = term.name
    let bind = normalize(term.bind)
    let body = (x) => normalize(term.body(x))
    let eras = term.eras
    allx(name, bind, body, eras)
  | lamx =>
    let name = term.name
    let body = (x) => normalize(term.body(x))
    let eras = term.eras
    lamx(name, body, eras)
  | appx =>
    case unit with normalize(term.func) as func : Hoas |unit
    case func
    with term.argm : Hoas
    with term.eras : Bool
    | varx => appx(func, normalize(term.argm), term.eras)
    | typx => appx(func, normalize(term.argm), term.eras)
    | allx => appx(func, normalize(term.argm), term.eras)
    | lamx => normalize(func.body(term.argm))
    | appx => appx(func, normalize(term.argm), term.eras)
    | slfx => appx(func, normalize(term.argm), term.eras)
    | insx => appx(func, normalize(term.argm), term.eras)
    | elix => appx(func, normalize(term.argm), term.eras)
    | annx => appx(func, normalize(term.argm), term.eras)
    | lgsx => appx(func, normalize(term.argm), term.eras)
    | holx => appx(func, normalize(term.argm), term.eras)
    | refx => appx(func, normalize(term.argm), term.eras)
  | slfx =>
    let name = term.name
    let type = (x) => normalize(term.type(x))
    slfx(name, type)
  | insx =>
    let type = normalize(term.type)
    let expr = normalize(term.expr)
    insx(type, expr)
  | elix =>
    case unit with normalize(term.expr) as expr : Hoas |unit
    case expr
    | varx => elix(expr)
    | typx => elix(expr)
    | allx => elix(expr)
    | lamx => elix(expr)
    | appx => elix(expr)
    | slfx => elix(expr)
    | insx => elix(expr)
    | elix => expr
    | annx => elix(expr)
    | lgsx => elix(expr)
    | holx => elix(expr)
    | refx => elix(expr)
  | annx =>
    let type = normalize(term.type)
    let expr = normalize(term.expr)
    let done = term.done
    annx(type, expr, done)
  | lgsx =>
    let msge = normalize(term.msge)
    let expr = normalize(term.expr)
    lgsx(msge, expr)
  | holx =>
    let name = term.name
    holx(name)
  | refx =>
    let name = term.name
    let eras = term.eras
    refx(name, eras)

// :::::::::::::::::
// :: Stringifier ::
// :::::::::::::::::

show.go(term: Term, names: List(String)) : Concat(Char)
  case term
  | var =>
    (x) => case at(String; term.indx, names) as got
      | none => list_to_concat(Char; "<unbound_var>", x)
      | some => list_to_concat(Char; got.value, x)
  | typ =>
    let type = list_to_concat(Char; "Type")
    (x) => type(x)
  | all =>
    let pun0 = list_to_concat(Char; "(")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; " : ")
    let bind = show.go(term.bind, names)
    let pun2 = list_to_concat(Char; ") -> ")
    let body = show.go(term.body, cons(String; term.name, names))
    (x) => pun0(name(pun1(bind(pun2(body(x))))))
  | lam =>
    let pun0 = list_to_concat(Char; "(")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; ") => ")
    let body = show.go(term.body, cons(String; term.name, names))
    (x) => pun0(name(pun1(body(x))))
  | app =>
    let pun0 = list_to_concat(Char; "(")
    let func = show.go(term.func, names)
    let pun1 = list_to_concat(Char; ")(")
    let argm = show.go(term.argm, names)
    let pun2 = list_to_concat(Char; ")")
    (x) => pun0(func(pun1(argm(pun2(x)))))
  | slf =>
    let pun0 = list_to_concat(Char; "type{")
    let name = list_to_concat(Char; term.name)
    let pun1 = list_to_concat(Char; "} ")
    //let type = show.go(term.type, names)
    let type = show.go(term.type, cons(String; term.name, names))
    (x) => pun0(name(pun1(type(x))))
  | ins =>
    let pun0 = list_to_concat(Char; "inst{")
    let type = show.go(term.type, names)
    let pun1 = list_to_concat(Char; "}");
    let expr = show.go(term.expr, names)
    (x) => pun0(type(pun1(expr(x))))
  | eli =>
    let pun0 = list_to_concat(Char; "elim{")
    let expr = show.go(term.expr, names)
    let pun1 = list_to_concat(Char; "}")
    (x) => pun0(expr(pun1(x)))
  | ann =>
    let type = show.go(term.type, names)
    let pun0 = list_to_concat(Char; " :: ")
    let expr = show.go(term.expr, names)
    (x) => type(pun0(expr(x)))
  | lgs =>
    let expr = show.go(term.expr, names)
    (x) => expr(x)
  | hol =>
    let name = list_to_concat(Char; term.name)
    (x) => name(x)
  | ref =>
    let name = list_to_concat(Char; term.name);
    (x) => name(x)
  : Concat(Char)
  
show(term: Term) : String
  show.go(term, [], [])

// ::::::::::::
// :: Parser ::
// ::::::::::::

// The parser below would be prettier with monads, but it
// avoids that in order to increase performance to the
// theoretical maximum, and decrease the dependency.

Parsed : Type
  Maybe(Pair(String, Term))

Vars : Type
  List(String)

// If `b` is successful, return it. Otherwise, try `a`.
try(a: Lazy(Parsed), b: Parsed) : Parsed
  case b
  with unit : Unit
  |none case force(_ a) as a
    |none none(_)
    |some some(_ a.value)
  |some some(_ b.value)

// Drops some characters from code
drop(amount: Nat, code: String) : String
  case amount |zero code |succ
  case code   |nil  code |cons
  drop(amount.pred, code.tail)

// Is this character allowed in names?
is_name_char(chr: Char) : Number
  (chr > 47) && (chr < 58)  || // 0-9
  (chr > 64) && (chr < 91)  || // A-Z 
  (chr > 96) && (chr < 123) || // a-z
  (chr === 95)                 // _ 

// Is this character a space?
is_space_char(chr: Char) : Number
  (chr === ' ')

// Removes leadig spaces
skip_spaces(code: String) : String
  case code |nil nil(_) |cons
  if is_space_char(code.head) then
    skip_spaces(code.tail)
  else
    code

// Matches an exact string, returns the remaining code
consume(value: String, code: String) : Maybe(String)
  let code = skip_spaces(code)
  case value |nil some(_ code) |cons
  case code  |nil none(_)      |cons
  if code.head === value.head then
    consume(value.tail, code.tail)
  else
    none(_)

// Parses name characters
parse_name(code: String) : Pair(String, String)
  let code = skip_spaces(code)
  case code |nil #[code, nil(_)] |cons
  if is_name_char(code.head) then
    get #[code, name] = parse_name(code.tail)
    #[code, cons(Char; code.head, name)]
  else
    #[code, nil(Char;)]

// Parses a grouping `(...)`
parse_grp(code: String, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses term
  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,term] = got.value

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  some(_ pair(__ code, term))

// Parses `(x:A)->B`
parse_all(code: String, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses variable name
  get #[code, name] = parse_name(code)

  // Parses `:`
  case consume(":",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses variable type
  case parse_term(code, vars) as got
  |none => none(_)
  |some => get #[code, type] = got.value

  // Parses erasure
  get #[code,eras] =
    case consume(";",code) as got
    |none => #[code, false]
    |some => #[got.value, true]

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses `->`
  case consume("->",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses body
  case parse_term(code, cons(_ name, vars)) as got
  |none => none(_)
  |some => get #[code, body] = got.value

  // Result
  some(_ pair(__ code, all(name, type, body, eras)))

// Parses `(x:A)=>B`
parse_lam(code: String, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses variable name
  get #[code, name] = parse_name(code)

  // Parses erasure
  get #[code,eras] =
    case consume(";",code) as got
    |none => #[code, false]
    |some => #[got.value, true]

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses `->`
  case consume("=>",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses body
  case parse_term(code, cons(_ name, vars)) as got
  |none => none(_)
  |some => get #[code, body] = got.value

  // Result
  some(_ pair(__ code, lam(name, body, eras)))

// Parses `Type`
parse_typ(code: String, vars: Vars) : Parsed
  case consume("Type",code) as got
  |none => none(_)
  |some => some(_ pair(__ got.value, typ))

// Parses variables
parse_var(code: String, vars: Vars) : Parsed
  get #[code,name] = parse_name(code)
  case find_index(_ string.equal(name), vars) as found
  |none =>
    case name |nil none(_) |cons
    some(_ pair(__ code, ref(name, false)))
  |some =>
    some(_ pair(__ code, var(found.value)))

// Parses a self type
parse_slf(code: String, vars: Vars) : Parsed
  case consume("type{",code) as got
  |none => none(_)
  |some => let code = got.value

  get #[code,name] = parse_name(code)

  case consume("}",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code, cons(_ name, vars)) as got
  |none => none(_)
  |some => get #[code,body] = got.value

  some(_ pair(__ code, slf(name, body)))

// Parses a self instantiation
parse_ins(code: String, vars: Vars) : Parsed
  case consume("inst{",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,type] = got.value

  case consume("}",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,expr] = got.value 

  some(_ pair(__ code, ins(type, expr)))

// Parses a self elimination
parse_eli(code: String, vars: Vars) : Parsed
  case consume("elim{",code) as got
  |none => none(_)
  |some => let code = got.value

  case parse_term(code,vars) as got
  |none => none(_)
  |some => get #[code,expr] = got.value

  some(_ pair(__ code, eli(expr)))

// Parses application
parse_app(code: String, func: Term, vars: Vars) : Parsed
  // Parses `(`
  case consume("(",code) as got
  |none => none(_)
  |some => let code = got.value

  // Parses argument
  case parse_term(code, vars) as got
  |none => none(_)
  |some => get #[code,argm] = got.value

  // Parses `)`
  case consume(")",code) as got
  |none => none(_)
  |some => let code = got.value

  some(_ pair(__ code, app(func, argm, false)))

// Postfix parses
// Attempts each one repeatedly, until all fail
parse_postfix(code: String, term: Term, vars: Vars) : Parsed
  //let parsed = parse_postfix.try(parse_app, parsed, vars)
  let parsed = none(_)
  let parsed = try((x)=>parse_app(code, term, vars), parsed)
  case parsed
  |none some(_ pair(__ code, term))
  |some get #[code,term] = parsed.value
  parse_postfix(code, term, vars)

// Parses terms
parse_term(code: String, vars: Vars) : Parsed
  let parsed = none(_)
  let parsed = try((x)=>parse_all(code, vars), parsed)
  let parsed = try((x)=>parse_lam(code, vars), parsed)
  let parsed = try((x)=>parse_grp(code, vars), parsed)
  let parsed = try((x)=>parse_typ(code, vars), parsed)
  let parsed = try((x)=>parse_slf(code, vars), parsed)
  let parsed = try((x)=>parse_ins(code, vars), parsed)
  let parsed = try((x)=>parse_eli(code, vars), parsed)
  let parsed = try((x)=>parse_var(code, vars), parsed)
  case parsed |none none(_) |some
  get #[code, term] = parsed.value
  parse_postfix(code, term, vars)

// ::::::::::::::
// :: Equality ::
// ::::::::::::::

identical(a: Term, b: Term) : Bool
  case a
  | var =>
    case b
    | var => nat_equal(a.indx, b.indx) 
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | typ =>
    case b
    | var => false
    | typ => true
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | all =>
    case b
    | var => false
    | typ => false
    | all => and(equal(a.bind,b.bind),equal(a.body,b.body))
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | lam =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => and(equal(a.body,b.body))
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | app =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => and(equal(a.func,b.func),equal(a.argm,b.argm))
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | slf =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | ins =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | eli =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | ann =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | lgs =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | hol =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  | ref =>
    case b
    | var => false
    | typ => false
    | all => false
    | lam => false
    | app => false
    | slf => false
    | ins => false
    | eli => false
    | ann => false
    | lgs => false
    | hol => false
    | ref => false
  
// :::::::::::::::::::
// :: Type-Checking ::
// :::::::::::::::::::

Context : Type
  List(Term)

ctx.get(ctx: Context, i: Nat) : Maybe(Term)
  case at(_ i, ctx) as got
  | none => none(_) 
  | some => some(_ shift(got.value, succ(i), 0n))

ctx.nil : Context
  nil(_)

ctx.ext(ctx: Context, term: Term) : Context
  cons(_ term, ctx)

// Type-checks a term
typecheck(term: Term, type: Maybe(Term), ctx: Context) : Maybe(Term)
  case term
  | var =>
    ctx.get(ctx, term.indx)
  | typ =>
    some(_ typ)
  | all =>
    let bind_t = typecheck(term.bind, some(_ typ), ctx)
    let ex_ctx = ctx.ext(ctx, term.bind)
    let body_t = typecheck(term.body, some(_ typ), ex_ctx)
    case bind_t |none none(_) |some
    case body_t |none none(_) |some
    some(_ typ)
  | lam =>
    case type |none none(_) |some
    case type.value as type
    | var => none(_)
    | typ => none(_)
    | all =>
      let ex_ctx = ctx.ext(ctx, type.bind)
      let body_t = typecheck(term.body, some(_ type.body), ex_ctx)
      case body_t |none none(_) |some
      some(_ all(term.name, type.bind, body_t.value, term.eras))
    | lam => none(_)
    | app => none(_)
    | slf => none(_)
    | ins => none(_)
    | eli => none(_)
    | ann => none(_)
    | lgs => none(_)
    | hol => none(_)
    | ref => none(_)
  | app =>
    let func_t = typecheck(term.func, none(_), ctx)
    case func_t |none none(_) |some
    case func_t.value as func_t
    | var => none(_)
    | typ => none(_)
    | all => none(_)
    | lam => none(_)
    | app => none(_)
    | slf => none(_)
    | ins => none(_)
    | eli => none(_)
    | ann => none(_)
    | lgs => none(_)
    | hol => none(_)
    | ref => none(_)
  | slf => some(_ typ)
  | ins => some(_ typ)
  | eli => some(_ typ)
  | ann => some(_ typ)
  | lgs => some(_ typ)
  | hol => some(_ typ)
  | ref => some(_ typ)
    
// ::::::::::
// :: Test ::
// ::::::::::

main : IO(Unit)
  let term_code = "(A) => (x) => x"
  let type_code = "(A : Type) -> (x : A) -> A"

  // Parses term
  let parsed_term = parse_term(term_code, [])
  case parsed_term |none print("Error parsing term.") |some

  // Parses type
  let parsed_type = parse_term(type_code, [])
  case parsed_type |none print("Error parsing type.") |some

  // Gets parsed term
  case parsed_term.value |pair
  let term = parsed_term.value.snd

  // Gets parsed type
  case parsed_type.value |pair
  let type = parsed_type.value.snd

  // Infers the term type
  let term_t = typecheck(term, some(_ type), [])
  case term_t |none print("Type error.") |some do {
    print(show(term));
    print(show(term_t.value))
  }
