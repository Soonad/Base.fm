import Base

// ### Inductive proofs

// Let's prove a similar theorem, but for negation on arbitrary-length bit-strings instead of plain booleans:

T Bits
| b0 {pred : Bits}
| b1 {pred : Bits}
| be

#bnot*n : !{case halt bits : Bits} -> Bits
| b0 => b1(bnot(bits.pred))
| b1 => b0(bnot(bits.pred))
| be => be

// Start with the theorem we want to prove:

// #prof*n : !{bits : Bits} -> <bnot(n)>(<bnot(n)>(bits)) == bits
//   ?
//   halt: ?


// Remember that `halt:` is mandatory on recursive definition to provide the base-case. TODO: explain why the `-#`s on the type. 

// The type checker complains:

// ```haskell
// Type mismatch.
// - Found type... Hole
// - Instead of... bnot(step(n), bnot(step(n), bits)) == bits
// - When checking ?
// - On expression {bits} => ?
// - With the following context:
// - n    : Ind
// - n    : Ind
// - prof : {bits : Bits} -> bnot(n, bnot(n, bits)) == bits
// - bits : Bits
// ```

// Notice that:

// 1. It asks for `P(step(n))` instead of `P(n)`.
// 2. We have, on context, `prof`, which gives us `P(n)`.

// That's because the body of a recursive function is actually the step case of inductive proof, so all we need to do is, assuming `P(n)`, prove `P(step(n))`!

// Let's match against `bits`, using `self` on the motive:

// #prof*n : !{bits : Bits} -> <bnot(n)>(<bnot(n)>(bits)) == bits
//   case/Bits bits
//   | b0 => ?
//   | b1 => ?
//   | be => ?
//   : <bnot(step(n))>(<bnot(step(n))>(self)) == self
//   halt: ?

// Now the complaint becomes:

// ```shell
// Type mismatch.
// - Found type... Hole
// - Instead of... bnot(step(n), bnot(step(n), b0(pred))) == b0(pred)
// - When checking ?
// - On expression {bits} => ?
// - With the following context:
// - n    : Ind
// - n    : Ind
// - prof : {bits : Bits} -> bnot(n, bnot(n, bits)) == bits
// - bits : Bits
// - pred : Bits
// ```

// This is better because now it expects `b0(pred)` instead of just `bits` . This allows the left-side of the equation to be reduced to:

// ```haskell
// b0(bnot(n, bnot(n, pred))) == b0(pred)
// ```

// This is perfect because we can use the inductive hypothesis to get this same equation, without the `b0`s. As in, we need to go...

// ```haskell
// from :    bnot(n, bnot(n, bs))  == b0(bs)
// to   : b0(bnot(n, bnot(n, bs))) ==    bs
// ```

// All we need is to add `b0` on both sides. We can do it with `cong`, from the base libraries (`Base@0`):

// #induc_proof.example1*n : !{bits : Bits} -> <bnot(n)>(<bnot(n)>(bits)) == bits
//   case/Bits bits
//   | b0 => cong(~Bits, ~Bits, ~(<bnot(n)>)((<bnot(n)>)(pred)), ~pred, ~b0, ~prof(pred))
//   | b1 => ?
//   | be => ?
//   : <bnot(step(n))>(<bnot(step(n))>(self)) == self
//   halt: ?

// TODO: should we have a built-in syntax to simplify `cong`?

// Now the checker complains about the `b1` case:

// ```shell
// Type mismatch.
// - Found type... Hole
// - Instead of... bnot(step(n), bnot(step(n), b1(pred))) == b1(pred)
// - When checking ?
// - On expression {pred} => ?
// - With the following context:
// - n    : Ind
// - n    : Ind
// - prof : {bits : Bits} -> bnot(n, bnot(n, bits)) == bits
// - bits : Bits
// - pred : Bits
// ```

// We can easily complete this proof now:

// ```haskell
// #prof*n : !{bits : Bits} -> <bnot(n)>(<bnot(n)>(bits)) == bits
//   case/Bits bits
//   | b0 => cong(~Bits, ~Bits, ~<bnot(n)>(<bnot(n)>(pred)), ~pred, ~b0, ~prof(pred))
//   | b1 => cong(~Bits, ~Bits, ~<bnot(n)>(<bnot(n)>(pred)), ~pred, ~b1, ~prof(pred))
//   | be => refl(~be)
//   : <bnot(step(n))>(<bnot(step(n))>(self)) == self
//   halt: refl(~bits)
// ```

// As usual, it could be simplified with case'd arguments:

#prof*n : !{case bits : Bits} -> <bnot(n)>(<bnot(n)>(bits)) == bits
| b0 => cong(~b0, prof(bits.pred))
| b1 => cong(~b1, prof(bits.pred))
| be => refl(~be)
halt: refl(~bits)

// Note that the big difference here, with relation to Agda/Coq proofs, is that, in their cases, since recursive functions are defined by structural recursion, inductive proofs are also defined by recursion on the structure. For example, if we wanted to prove this theorem in Agda, we'd just match the bit-string, prove the base case by reflexivity, and prove the recursive case by calling `prof` recursively on `pred`.

// In Formality, it **looks** like the proof is the same, but there is a subtle, yet important, difference: under the hoods, we're not actually recursing on the `Bits` structure. Instead, we're folding over `n : Ind`, a datatype capturing the inductive hypothesis on natural numbers. As such, in order to prove that `bnot(n, bnot(n, bits)) == bits` hold for any `n`, we first must prove that it is true for `n == 0`, i.e., when `bits` has a maximum recursion depth of `0` (i.e., is "out-of-gas"), which is true by reflexivity since the function returns `bits` itself. We then prove that assuming this is true for a maximum recursion depth of `n`, then it is also true for `bits(step(n))`. This is the `step` case, which coincides with Agda's proof.

// Proving that kind of inductive theorem on Formality is a little more verbose than in Agda, since you have to wrap the whole proof inside `Ind`, and always tell the compiler what to do when the function "runs out of gas". In exchange, since termination is guaranteed by EAL, there is no "structural recursion" checker, so you're allowed to be more flexible in your recursive definitions.
