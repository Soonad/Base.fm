// Formality functions are anonymous expressions, like Haskell’s lambdas. There
// are no multi-argument lambdas.

// syntax	                         | description
// ------------------------------- | ---------------------------------------------------------------
// {x : A, y : B, z : C, ...} -> D | Function type with args x : A, y : B, z : C, returning D
// {x, y, z, ...} body	           | A function that receives the arguments x, y, z and returns body
// f(x, y, z, ...)	               | Applies the function f to the arguments x, y, z (curried)

functions.example_0a : Word -> Word -> Word
  {x, y} x + y

functions.example_0a_test : Word
  functions.example_0a (40, 2)

// When you write the variable names, lambdas are added implicity. For example:

functions.example_0b : {x : Word, y : Word} -> Word
  x + y

functions.example_0b_test : Word
  functions.example_0b(40, 2)

// An inline function (lambda expression):

functions.example_1 : Word
  ({x : Word, y : Word} x + y)(40, 2)

// You can annotate the full type rather than the type of each variable:

functions.example_2 : Word
  (({x, y} x + y) :: Word -> Word -> Word)(40, 2)

// You can avoid types. This won’t type-check, but can still be ran:

// functions.example_3
//   ({x, y} x + y)(40, 2)

// Lambdas and applications can be erased with a ~, which causes them to vanish
// from the compiled output. This is useful, for example, to write polymorphic
// functions without extra runtime costs. For example, on the code below, id is
// compiled to {x} x, and main is compiled to id(42). The first argument
// disappears from the runtime.

functions.example_4 : {~T : Type, x : T} -> T
  x

functions.example_4_test : Word
  functions.example_4(~Word, 42)

// Formality functions are affine, which means you can’t use a variable more
// than once. For example, the program below isn’t allowed, because b is used
// twice:

// functions.example_5 : {b : Bool} -> [:Bool, Bool]
//   [b, b]

// While this sounds limiting, there are many ways to deal with it, as will be
// explained later, and it is extremelly important for both logical consistency
// and runtime performance.
