import Data.Function

T Profunctor {F : Type -> Type -> Type}
| profunctor

  // A mapping function for both functors
  { dimap :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , ~D : Type
    , f  : A -> B
    , g  : C -> D
    , x  : F(B,C)
    } -> F(A,D)

  // Satisfying the identity law
  , identity :
    {~A  : Type
    ,~C  : Type
    , fac : F(A,C)
    } -> dimap(~A, ~A, ~C, ~C, id(~A),id(~C),fac) == fac

  // Satisfying the composition law
  , composition :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , ~X : Type
    , ~Y : Type
    , ~Z : Type
    , g  : B -> C
    , f  : A -> B
    , i  : Y -> Z
    , h  : X -> Y
    , fax : F(A,X)
    } -> let di1 = dimap(~A, ~C, ~X, ~Z)
         let di2 = dimap(~B, ~C, ~Y, ~Z)
         let di3 = dimap(~A, ~B, ~X, ~Y)
         di1({x} f(g(x)), {x} i(h(x)), fax) == di2(g, i, di3(f, h, fax))
  }

// A generic dimap for profunctors
dimap :
  { ~F : Type -> Type -> Type
  , case pro : Profunctor(F)
  , ~A : Type
  , ~B : Type
  , ~C : Type
  , ~D : Type
  ,  f : A -> B
  ,  g : C -> D
  } -> F(B,C) -> F(A,D)
| profunctor => pro.dimap(~A, ~B, ~C, ~D, f, g)

// map over the first functor
lmap :
  { ~F : Type -> Type -> Type
  , case pro : Profunctor(F)
  , ~A : Type
  , ~B : Type
  , ~C : Type
  ,  f : A -> B
  } -> F(B,C) -> F(A,C)
| profunctor => pro.dimap(~A, ~B, ~C, ~C, f, id(~C))

// map over the second functor
rmap :
  { ~F : Type -> Type -> Type
  , case pro : Profunctor(F)
  , ~A : Type
  , ~C : Type
  , ~D : Type
  ,  g : C -> D
  } -> F(A,C) -> F(A,D)
| profunctor => pro.dimap(~A, ~A, ~C, ~D, id(~A), g)

