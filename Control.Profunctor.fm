import Data.Function

T Profunctor { F : Type -> Type -> Type
             , s : {A : Type, B : Type} -> Setoid(F(A,B))
             }
| profunctor

  // A mapping function for both functors
  { dimap :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , ~D : Type
    , f  : B -> A
    , g  : C -> D
    , x  : F(A,C)
    } -> F(B,D)

  // Satisfying the identity law
  , identity :
    {~A  : Type
    ,~C  : Type
    , fac : F(A,C)
    } -> case/Setoid s(A,C) as s | setoid =>
           s.R(dimap(~A, ~A, ~C, ~C, id(~A),id(~C),fac), fac)
         : Type

  // Satisfying the composition law
  , composition :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , ~X : Type
    , ~Y : Type
    , ~Z : Type
    , f  : B -> A
    , g  : C -> B
    , h  : Y -> Z
    , i  : X -> Y
    , fax : F(A,X)
    } -> let di1 = dimap(~A, ~C, ~X, ~Z)
         let di2 = dimap(~B, ~C, ~Y, ~Z)
         let di3 = dimap(~A, ~B, ~X, ~Y)
         case/Setoid s(C,Z) as s | setoid =>
           s.R(di1({x} f(g(x)), {x} h(i(x)), fax), di2(g, h, di3(f, i, fax)))
         : Type
  }

// A generic dimap for profunctors
dimap :
  { ~F : Type -> Type -> Type
  , ~s : {A : Type, B : Type} -> Setoid(F(A,B))
  , case pro : Profunctor(F,s)
  , ~A : Type
  , ~B : Type
  , ~C : Type
  , ~D : Type
  ,  f : B -> A
  ,  g : C -> D
  } -> F(A,C) -> F(B,D)
| profunctor => pro.dimap(~A, ~B, ~C, ~D, f, g)

// map over the first functor
lmap :
  { ~F : Type -> Type -> Type
  , ~s : {A : Type, B : Type} -> Setoid(F(A,B))
  , case pro : Profunctor(F,s)
  , ~A : Type
  , ~B : Type
  , ~C : Type
  ,  f : B -> A
  } -> F(A,C) -> F(B,C)
| profunctor => pro.dimap(~A, ~B, ~C, ~C, f, id(~C))

// map over the second functor
rmap :
  { ~F : Type -> Type -> Type
  , ~s : {A : Type, B : Type} -> Setoid(F(A,B))
  , case pro : Profunctor(F,s)
  , ~A : Type
  , ~C : Type
  , ~D : Type
  ,  g : C -> D
  } -> F(A,C) -> F(A,D)
| profunctor => pro.dimap(~A, ~A, ~C, ~D, id(~A), g)

