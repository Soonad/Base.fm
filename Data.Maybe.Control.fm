import Data.Maybe
import Control.Functor
import Control.Monad

maybe.functor : Functor(Maybe)

  // A mapping function
  let map = {~A, ~B, f, x}
    case/Maybe x
    | just => just(~B, f(some))
    | none => none(~B)
    : Maybe(B)

  // Satisfying the identity law
  let identity = {~A, ma}
    case/Maybe ma
    | just => refl(~just(~A,some))
    | none => refl(~none)
    : map(~A,~A,id(~A),self) == self

  // Satisfying the composition law
  let composition = {~A, ~B, ~C, g, f, ma}
    case/Maybe ma
    | just => refl(~just(~C,(g(f(some)))))
    | none => refl(~none)
    : map(~A,~C,{x:A} g(f(x)),self) == map(~B,~C,g,map(~A,~B,f,self))

  functor(~Maybe,map,identity,composition)

maybe.monad : Monad(Maybe)

  // A way to wrap values
  let pure = {~A, x} just(~A,x)

  // A function that, given an unwrapped value, does something and wraps it
  let bind = {~A, ~B, f, ma}
    case/Maybe ma
    | just => f(some)
    | none => none(~B)
    : Maybe(B)

  // Satisfying this identity law
  let identity1 = {~A, ~B, x, f}
    case/Maybe f(x)
    | just => refl(~just(~B,some))
    | none => refl(~none)
    : self == self

  // Satisfying this identity law
  let identity2 = {~A, m}
    case/Maybe m
    | just => refl(~just(~A,some))
    | none => refl(~none)
    : bind(~A,~A,pure(~A),self) == self

  // Satisfying this associativity law
  let associative = {~A, ~B, ~C, m, f, g}
    case/Maybe m
    | just =>
      case/Maybe f(some)
      | just =>
        case/Maybe g(some)
        | just => refl(~just(~C,some))
        | none => refl(~none)
        : self == self
      | none => refl(~none)
      : bind(~B,~C,g,self) == bind(~B,~C,g,self)
    | none => refl(~none)
    : let b1 = bind(~B, ~C)
      let b2 = bind(~A, ~B)
      let b3 = bind(~A, ~C)
      let b4 = bind(~B, ~C)
      b1(g,b2(f,self)) == b3({x} b4(g,f(x)),self)

  monad(~Maybe,pure,bind,identity1,identity2,associative)
