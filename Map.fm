import Bits
import Maybe
import Nat
import List

// A Map from Bits to values
T Map<A>
| leaf
| node(val : Maybe(A), lft : Map(A), rgt : Map(A))


empty(~A) : Map(A)
  leaf(~A)

singleton(~A, x : A) : Map(A)
  node(~A, some(~A,x), leaf(~A), leaf(~A))

map_from_list(~A, xs : List([:Bits, A])) : Map(A)
  case xs
  | nil  => leaf(~A)
  | cons => get [k,v] = xs.head
    set(~A,k,v,map_from_list(~A,xs.tail))
  : Map(A)

elems(~A, m : Map(A)) : List(A)
  case m
  | leaf => nil(~A)
  | node =>
    let rest = concat(~A,elems(~A, m.lft), elems(~A, m.rgt))
    case m.val as mv
    + rest : List(A)
    | none => rest
    | some => cons(~A,mv.value,rest)
    : List(A)
  : List(A)

// Gets a value
get(~A, bits : Bits, map : Map(A)) : Maybe(A)
  case bits
  + map : Map(A)
  + get(~A) as rec : (bits : Bits, map : Map(A)) -> Maybe(A)
  | be => case map
    | leaf => none(~A)
    | node => map.val
    : Maybe(A)
  | b0 => case map
    | leaf => none(~A)
    | node => rec(bits.pred, map.lft)
    : Maybe(A)
  | b1 => case map
    | leaf => none(~A)
    | node => rec(bits.pred, map.rgt)
    : Maybe(A)
  : Maybe(A)

// Sets a value
set(~A, bits : Bits, val : A, map : Map(A)) : Map(A)
  case bits
  + val : A
  + map : Map(A)
  + set(~A) as rec : Bits -> A -> Map(A) -> Map(A)
  | be => case map
    + some(~A, val) as some_val : Maybe(A)
    | leaf => node(~A, some_val, leaf(~A), leaf(~A))
    | node => node(~A, some_val, map.lft, map.rgt)
    : Map(A)
  | b0 => case map
    + rec(bits.pred, val) as rec : Map(A) -> Map(A)
    | leaf => node(~A, none(~A), rec(leaf(~A)), leaf(~A))
    | node => node(~A, map.val, rec(map.lft), map.rgt)
    : Map(A)
  | b1 => case map
    + rec(bits.pred, val) as rec : Map(A) -> Map(A)
    | leaf => node(~A, none(~A), leaf(~A), rec(leaf(~A)))
    | node => node(~A, map.val, map.lft, rec(map.rgt))
    : Map(A)
  : Map(A)

// Updates a value, return a function of it and the map
query(~A, qry : A -> [:A,A], bits : Bits, map : Map(A)) 
: [:Map(A), Maybe(A)]
  let rec = query(~A)
  case bits
  + map : Map(A)
  + rec : (qry : A -> [:A,A], bits : Bits, map : Map(A))
          -> [:Map(A), Maybe(A)]
  + qry : A -> [:A, A]
  | be => case map
    | leaf => [leaf(~A), none(~A)]
    | node =>
      case map.val as mval
      + map.lft : Map(A)
      + map.rgt : Map(A)
      | none => 
        [node(~A, none(~A), map.lft, map.rgt), none(~A)]
      | some =>
        get [val0, val1] = qry(mval.value)
        [ node(~A, some(~A, val0),
          map.lft, map.rgt),
          some(~A, val1)
        ]
      : [:Map(A), Maybe(A)]
    : [:Map(A), Maybe(A)]
  | b0 => case map
    | leaf => [leaf(~A), none(~A)]
    | node =>
      get [lft, val] = rec(qry, bits.pred, map.lft)
      [node(~A, map.val, lft, map.rgt), val]
    : [:Map(A), Maybe(A)]
  | b1 => case map
    | leaf => [leaf(~A), none(~A)]
    | node => 
      get [rgt, val] = rec(qry, bits.pred, map.rgt)
      [node(~A, map.val, map.lft, rgt), val]
    : [:Map(A), Maybe(A)]
  : [:Map(A), Maybe(A)]



// ::::::::::::::
// :: Theorems ::
// ::::::::::::::

// Getting a stored value returns it
Map.Fact0(A, bits : Bits, val : A, map : Map(A)) : Type
  let lft = some(~A, val)
  let rgt = get(~A, bits, set(~A, bits, val, map))
  Equal(Maybe(A), lft, rgt)

// Proof
Map.fact0(~A, bits : Bits, val : A, map : Map(A))
: Map.Fact0(A, bits, val, map)
  case bits
  + map : Map(A)
  + val : A
  | be =>
    case map
    + val : A
    | leaf => refl(~Maybe(A), ~some(~A, val))
    | node => refl(~Maybe(A), ~some(~A, val))
    : Map.Fact0(A, be, val, map)
  | b0 =>
    let rec = Map.fact0(~A, bits.pred, val)
    case map
    + rec : (map : Map(A))
            -> Map.Fact0(A, bits.pred, val, map)
    | leaf => rec(leaf(~A))
    | node => rec(map.lft)
    : Map.Fact0(A, b0(bits.pred), val, map)
  | b1 =>
    let rec = Map.fact0(~A, bits.pred, val)
    case map
    + rec : (map : Map(A))
            -> Map.Fact0(A, bits.pred, val, map)
    | leaf => rec(leaf(~A))
    | node => rec(map.rgt)
    : Map.Fact0(A, b1(bits.pred), val, map)
  : Map.Fact0(A, bits, val, map)

// ::::::::::::::
// :: Examples ::
// ::::::::::::::

Map.ex0 : Maybe(Number)
  let map = leaf(~Number)
  let map = set(~Number, 1111111101101110b, 1337, map)
  get(~Number, 1111111101101110b, map)

Map.ex1 : [:Maybe(Number), :Maybe(Number), Maybe(Number)]
  let qry     = (a) => [a, a]
  let map     = leaf(~Number)
  let map     = set(~Number, 10100100b, 10, map)
  let map     = set(~Number, 01100010b, 20, map)
  let map     = set(~Number, 10111001b, 30, map)
  get [map,a] = query(~Number, qry, 10100100b, map)
  get [map,b] = query(~Number, qry, 01100010b, map)
  get [map,c] = query(~Number, qry, 10111001b, map)
  [a, b, c]
