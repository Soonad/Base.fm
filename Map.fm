import Bits
import Maybe
import Nat
import List

// A Map from Bits to values
T Map<A>
| empty
| multi(val: Maybe(A), lft: Map(A), rgt: Map(A))

singleton_map(A; x: A) : Map(A)
  multi(A; some(_ x), empty(_), empty(_))

// Gets a value
lookup(A; bits: Bits, map: Map(A)) : Maybe(A)
  case bits
  + map    : Map(A)
  + lookup : (A; bits: Bits, map: Map(A)) -> Maybe(A)
  | be => case map
    | empty => none(_)
    | multi => map.val
  | b0 => case map
    | empty => none(_)
    | multi => lookup(_ bits.pred, map.lft)
  | b1 => case map
    | empty => none(_)
    | multi => lookup(_ bits.pred, map.rgt)

// Sets a value
insert(A; bits: Bits, val: A, map: Map(A)) : Map(A)
  case bits
  + val: A
  + map: Map(A)
  + insert: (A: Type;) -> Bits -> A -> Map(A) -> Map(A)
  | be => case map
    + some(A; val) as val : Maybe(A)
    | empty => multi(_ val, empty(_), empty(_))
    | multi => multi(_ val, map.lft, map.rgt)
  | b0 => case map
    + insert(A; bits.pred, val) as insert : Map(A) -> Map(A)
    | empty => multi(_ none(_), insert(empty(_)), empty(_))
    | multi => multi(_ map.val, insert(map.lft), map.rgt)
  | b1 => case map
    + insert(A; bits.pred, val) as insert : Map(A) -> Map(A)
    | empty => multi(_ none(_), empty(_), insert(empty(_)))
    | multi => multi(_ map.val, map.lft, insert(map.rgt))

list_to_map(A; xs : List([:Bits, A])) : Map(A)
  case xs
  | nil  => empty(_)
  | cons =>
    get [k,v] = xs.head
    insert(_ k, v, list_to_map(_ xs.tail))

map_elements(A; map : Map(A)) : List(A)
  case map
  | empty => nil(_)
  | multi => 
    let lft = map_elements(_ map.lft) 
    let rgt = map_elements(_ map.rgt)
    let all = concat(_ lft, rgt)
    case map.val as val
    + all : List(A)
    | none => all
    | some => cons(_ val.value, all)

//// Updates a value, return a function of it and the map
query(A; qry : A -> [:A,A], bits : Bits, map : Map(A)) : [:Map(A), Maybe(A)]
  let rec = query(A;)
  case bits
  + map : Map(A)
  + rec : (qry : A -> [:A,A], bits : Bits, map : Map(A))
    -> [:Map(A), Maybe(A)]
  + qry : A -> [:A, A]
  | be => case map
    | empty =>
      [empty(_), none(_)]
    | multi =>
      case map.val as mval
      + map.lft : Map(A)
      + map.rgt : Map(A)
      | none => 
        let map = multi(_ none(_), map.lft, map.rgt)
        let val = none(_)
        [map, val]
      | some =>
        get [val0, val1] = qry(mval.value)
        let map = multi(_ some(_ val0), map.lft, map.rgt)
        let val = some(_ val1)
        [map, val]
      : [:Map(A), Maybe(A)]
    : [:Map(A), Maybe(A)]
  | b0 => case map
    | empty => [empty(_), none(_)]
    | multi =>
      get [lft, val] = rec(qry, bits.pred, map.lft)
      let map = multi(_ map.val, lft, map.rgt)
      [map, val]
    : [:Map(A), Maybe(A)]
  | b1 => case map
    | empty => [empty(_), none(_)]
    | multi => 
      get [rgt, val] = rec(qry, bits.pred, map.rgt)
      let map = multi(_ map.val, map.lft, rgt)
      [map, val]
    : [:Map(A), Maybe(A)]

// Theorems
// --------

// Getting a stored value returns it
LookupInsert(A, bits: Bits, val: A, map: Map(A)) : Type
  let lft = some(_ val)
  let rgt = lookup(_ bits, insert(_ bits, val, map))
  Equal(Maybe(A), lft, rgt)

// Proof
lookup_insert(A; bits : Bits, val : A, map : Map(A))
: LookupInsert(A, bits, val, map)
  case bits
  + map : Map(A)
  + val : A
  | be =>
    case map
    + val : A
    | empty => refl(_ some(A; val);)
    | multi => refl(_ some(A; val);)
    : LookupInsert(A, be, val, map)
  | b0 =>
    let rec = lookup_insert(A; bits.pred, val)
    case map
    + rec : (map : Map(A))
      -> LookupInsert(A, bits.pred, val, map)
    | empty => rec(empty(_))
    | multi => rec(map.lft)
    : LookupInsert(A, b0(bits.pred), val, map)
  | b1 =>
    let rec = lookup_insert(A; bits.pred, val)
    case map
    + rec : (map : Map(A))
      -> LookupInsert(A, bits.pred, val, map)
    | empty => rec(empty(_))
    | multi => rec(map.rgt)
    : LookupInsert(A, b1(bits.pred), val, map)
  : LookupInsert(A, bits, val, map)

// Examples
// --------

map_example0 : Maybe(Number)
  let map = empty(_)
  let map = insert(_ 1111111101101110b, 1337, map)
  lookup(_ 1111111101101110b, map)

map_example1 : [:Maybe(Number), Maybe(Number)]
  let qry     = (a) => [a, a]
  let map     = empty(_)
  let map     = insert(_ 10100100b, 10, map)
  let map     = insert(_ 01100010b, 20, map)
  let map     = insert(_ 10111001b, 30, map)
  get [map,a] = query(Number; qry, 10100100b, map)
  get [map,b] = query(Number; qry, 01100010b, map)
  [a, b]
