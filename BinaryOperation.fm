import Logic open

// Properties of Operations
Associative : {A:Type, f:A -> A -> A} -> Type
  {x:A, y:A, z:A} -> f(f(x,y),z) == f(x,f(y,z))

Commutative : {A:Type, f:A -> A -> A} -> Type
  {x:A, y:A} -> f(x,y) == f(y,x)

Distributive : {A:Type, f:A -> A -> A, g:A -> A -> A} -> Type
  type(And({x:A, y:A, z:A} -> f(x, g(y,z)) == g(f(x,y),f(x,z))
          ,{x:A, y:A, z:A} -> f(g(y,z), x) == g(f(y,x),f(z,x))
          ))

Medial : {A:Type, f:A -> A -> A} -> Type
  {x:A, y:A, u:A, z:A} -> f(f(x,y), f(u,z)) == f(f(x,u),f(y,z))

Semimedial : {A:Type, f:A -> A -> A} -> Type
  type(And({x:A, y:A, z:A} -> f(f(x,x), f(y,z)) == f(f(x,y),f(x,z))
          ,{x:A, y:A, z:A} -> f(f(x,x), f(y,z)) == f(f(x,y),f(x,z))
          ))

Idempotent : {A:Type, f:A -> A -> A} -> Type; {x:A} -> f(x,x) == x
Unipotent : {A:Type, f:A -> A -> A} -> Type; {x:A, y:A} -> f(x,x) == f(y,y)
Zeropotent : {A:Type, f:A -> A -> A} -> Type
  {x:A, y:A} -> [:f(f(x,x),y) == f(x,x), f(y,f(x,x)) == f(x,x)]

Alternative : {A:Type, f:A -> A -> A} -> Type
  type(And({x:A, y:A} -> f(f(x,x),y) == f(x,f(x,y))
          ,{x:A, y:A} -> f(f(x,x),y) == f(x,f(x,y))
          ))

PowerAssociative : {A:Type, f:A -> A -> A} -> Type;
  {x:A} -> f(f(x,x),x) == f(x,f(x,x))

Null : {A:Type, f:A -> A -> A} -> Type;
  type(And( {x:A, y:A} -> f(x,y) == x
          , {u:A, v:A} -> f(u,v) == v
          ))

Cancellative : {A:Type, f:A -> A -> A} -> Type;
  type(And({x:A, y:A, z:A, :f(x,y) == f(x,z)} -> y == z
          ,{x:A, y:A, z:A, :f(y,x) == f(z,x)} -> y == z
          ))

// Properties of elements
Zero : {A:Type, f:A -> A -> A, e:A} -> Type
  type(And({y:A} -> f(y,e) == e
          ,{y:A} -> f(e,y) == e
          ))

Identity : {A:Type, f:A -> A -> A, e:A} -> Type
  type(And({y:A} -> f(y,e) == y
          ,{y:A} -> f(e,y) == y
          ))

LeftInverse :
{A:Type, f:A -> A -> A, e:A, p:Identity(A,f,e)} -> Type
  {y:A} -> [x:A, f(x,y) == e]

RightInverse : {A:Type, f:A -> A -> A, e:A, p:Identity(A,f,e)} -> Type
  {y:A} -> [x:A, f(y,x) == e]

Inverse: {A:Type, f:A -> A -> A, e:A, p:Identity(A,f,e)} -> Type
  {y:A} -> [x:A, [:f(y,x) == e, f(x,y) == e]]

