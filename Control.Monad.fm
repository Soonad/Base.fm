import Data.Function

// A Monad consists of...
T Monad {M : Type -> Type, s : {A : Type} -> Setoid(M(A))}

// A monoid in the category of endofunctors why do you even ask
| monad

  // A way to wrap values
  { pure : { ~A : Type, x : A} -> M(A)

  // A function that, given an unwrapped value, does something and wraps it
  , bind : { ~A : Type, ~B : Type, f : A -> M(B), m : M(A)} -> M(B)

  // Satisfying this identity law
  , identity1 :
    { ~A : Type
    , ~B : Type
    , x : A
    , f : A -> M(B)
    } -> case/Setoid s(B) as s | setoid =>
          s.R(bind(~A, ~B, f, pure(~A, x)), f(x))
         : Type


  // Satisfying this identity law
  , identity2 : {~A : Type, m : M(A)} -> 
      case/Setoid s(A) as s | setoid =>
        s.R(bind(~A, ~A, pure(~A), m), m)
      : Type

  // Satisfying this associativity law
  , associative :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , m : M(A)
    , f : A -> M(B)
    , g : B -> M(C)
    } -> let b1 = bind(~B, ~C)
         let b2 = bind(~A, ~B)
         let b3 = bind(~A, ~C)
         let b4 = bind(~B, ~C)
        case/Setoid s(C) as s | setoid =>
          s.R(b1(g, b2(f,m)), b3({x} b4(g, f(x)), m))
        : Type
  }

// A generic pure for monads
pure :
  { ~M : Type -> Type
  , ~s : {A : Type} -> Setoid(M(A))
  , case mon : Monad(M,s)
  , ~A : Type
  , x : A
  } -> M(A)
| monad => mon.pure(~A, x)

// A generic bind for monads
bind :
  { ~M : Type -> Type
  , ~s : {A : Type} -> Setoid(M(A))
  , case mon : Monad(M,s)
  , ~A : Type
  , ~B : Type
  ,  f : A -> M(B)
  } -> M(A) -> M(B)
| monad => mon.bind(~A, ~B, f)

// A generic join for monads
join :
  { ~M : Type -> Type
  , ~s : {A : Type} -> Setoid(M(A))
  , case mon : Monad(M,s)
  , ~A : Type
  ,  mma : M(M(A))
  } -> M(A)
| monad => mon.bind(~M(A), ~A, id(~M(A)), mma)

