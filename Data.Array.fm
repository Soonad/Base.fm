import Base

// TODO: 
// - abstract builder to avoid code duplication
// - array updater
// - instead of Word, use Copiable
// - clean up and finish API

Array : {n : Nat} -> Type
  case/Nat n
  | succ => [x : Array(pred), Array(pred)]
  | zero => Word
  : Type

// ::::::::::::
// :: Getter ::
// ::::::::::::

ArgetBuilder : {n : Nat} -> Type
  { ~A : Type,
    E  : {fn : Array(n) -> Word} -> A
  } -> A

arget_builder.zero : ArgetBuilder(zero)
  {~A, E} E({a} a)

arget_builder.succ : {~n : Nat, side : Word, gb : ArgetBuilder(n)} -> ArgetBuilder(succ(n))
  {~A, E}
    let type = {fn : Array(succ(n))} -> Word
    let func = {fn, a}
      get [a, b] = a
      fn(if side: b else: a)
    E(gb(~type, func))
  
#arget_builder*N : !{path : Word} -> [idx : Word, ArgetBuilder(<nat(N)>)]
  get [idx, arb] = arget_builder(path)
  cpy idx = idx
  log([idx, (path .>> idx) .& 1])
  [idx + 1, arget_builder.succ(~<nat(N)>, (path .>> idx) .& 1, arb)]
halt: [0, arget_builder.zero]

arget.test
  dup arget = arget_builder*4
  dup arget = #{x : Word} snd(arget(x))(~Array(0n4) -> Word, {x}x)
  # let arr = [[[[0,1],[2,3]],[[4,5],[6,7]]], [[[8,9],[10,11]],[[12,13],[14,15]]]]
    arget(4, arr) + arget(8, arr)

// ::::::::::::
// :: Reader ::
// ::::::::::::

ArreadBuilder : {n : Nat} -> Type
  { ~A : Type,
    E  : {fn : Array(n) -> [x : Word, Array(n)]} -> A
  } -> A

arread_builder.zero : ArreadBuilder(zero)
  {~A, E} E({a} cpy a = a; [a, a])

arread_builder.succ : {~n : Nat, side : Word, gb : ArreadBuilder(n)} -> ArreadBuilder(succ(n))
  {~A, E}
    let type = {fn : Array(succ(n))} -> [x : Word, Array(succ(n))]
    let func = {fn, arr}
      let swap = {a : Array(n), b : Array(n)} [b, a]
      let keep = {a : Array(n), b : Array(n)} [a, b]
      get [a, b] = arr
      get [a, b] = (if side: swap else: keep)(a,b)
      get [w, a] = fn(a)
      get [a, b] = (if side: swap else: keep)(a,b)
      [w, [a, b]]
    E(gb(~type, func))
  
#arread_builder*N : !{path : Word} -> [idx : Word, ArreadBuilder(<nat(N)>)]
  get [idx, arb] = arread_builder(path)
  cpy idx = idx
  log([idx, (path .>> idx) .& 1])
  [idx + 1, arread_builder.succ(~<nat(N)>, (path .>> idx) .& 1, arb)]
halt: [0, arread_builder.zero]

arread.test
  dup arread = arread_builder*4
  dup arread = #{x : Word} snd(arread(x)) (~Array(0n4) -> [x : Word, Array(0n4)], {x}x)
  # let arr = [[[[0,1],[2,3]],[[4,5],[6,7]]], [[[8,9],[10,11]],[[12,13],[14,15]]]]
    get [a, arr] = arread(4, arr)
    get [b, arr] = arread(8, arr)
    a + b
