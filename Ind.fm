// The inductive hypothesis on nats. Erases to Church.
Ind : Type
  $ self
  {~P     : {r : Ind} -> Type} ->
  {step   : ! {~r : Ind, i : P(r)} -> P(step(r))} ->
  ! {base : P(base)} ->
    P(self)

step : {r : Ind} -> Ind
  new<Ind>{~P, step}
  dup step = step
  dup func = (%r)(~P, #step)
  # {base}
    step(~r, func(base))

base : Ind
  new<Ind>{~P, step}
  dup step = step
  # {base}
    base

// Since `Ind` is just the type of the inductive hypothesis wrapped on self,
// then induction on `Ind` is just identity.
ind :
  {n     : Ind
  , ~P   : {n : Ind} -> Type
  , step : ! {~n : Ind, i : P(n)} -> P(step(n))
  , stop : ! P(base)
  } -> ! P(n)
  dup step = step
  dup stop = stop
  dup loop = (%n)(~P, #step)
  # loop(stop)

// Induction without indices is just recursion.
rec : {r : Ind, ~T : Type, step : !{x : T} -> T, base : !T} -> !T
  dup step = step
  dup base = base
  dup loop = (%r)(~{r} => T, #{~n} => step)
  # loop(base)

// Doubles the number of steps of an `ind`.
twice : {n : Ind} -> Ind
  new<Ind> {~P, STEP}
  dup STEP = STEP
  let moti = {n} P(twice(n))
  let STEP = {~n, i} => STEP(~step(twice(n)), STEP(~twice(n), i))
  dup loop = (%n)(~moti, #STEP)
  # {base} loop(base)

// Adds two Inds.
sum : {a : Ind, b : Ind} -> Ind
  new<Ind> {~P, S}
  dup S = S
  dup A = (%a)(~{a} => P(sum(a, b)), #{~n, h} => S(~sum(n, b), h))
  dup B = (%b)(~{b} => P(sum(base, b)), #{~n, h} => S(~sum(base, n), h))
  # {z} => A(B(z))
