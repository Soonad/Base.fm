import Ind open
import Equality open

T List <A : Type>
| cons {head : A, tail : List(A)}
| nil

head : {~T : Type, default : T, list : List(T)} -> T
  @ list ~> T
  | cons => head
  | nil  => default

tail : {~T : Type, list : List(T)} -> List(T)
  @ list ~> List(T)
  | cons => tail
  | nil  => nil(~T)

take : {~T : Type, default : T, list : List(T)} -> [x : T, List(T)]
  @ list ~> [x : T, List(T)]
  | cons => [head, tail]
  | nil  => [default, nil<T>]

// ::::::::::::::
// :: Identity ::
// ::::::::::::::

// Normal identity
!list.id*n : !{~A : Type, *list : List(A)} -> List(A)
  @ list ~> List(A)
  | cons => cons<A>(head, list.id<A>(tail))
  | nil  => nil<A>

// Id example
!list.id.example : !List(Word)
  list.id*256<Word>(Word$[1,2,3,4])

// Fusible list.identity
!list.id-f*n : !{~A : Type, *list : List(A)} -> List(A)
  new<List(A)>{~P, cons, nil}
  @ list ~> P(-#(list.id-f.step)(~n, list.id-f, ~A, self))
  | cons => cons(head, list.id-f<A>(tail))
  | nil  => nil

// From 1.7m to 3.2k rewrites by using `list.id-f` to build the list
list.id-f.example
  let list = Word$[1, 2, 3, 4, 5, 6, 7]
  dup list.id   = list.id*256
  dup list.id-f = list.id-f*256
  dup list = rec(*10000, ~List(Word), #list.id-f<Word>, #list)
  # list.id<Word>(list)

// :::::::::::::
// :: Mapping ::
// :::::::::::::

// Normal map
!map*n : {~A : Type, ~B : Type, f : !A -> B} -> ! {list : List(A)} -> List(B)
  @ list ~> List(B)
  | cons => cons<B>(f(head), map(tail))
  | nil  => nil<B>
  * nil<B>

// Map example
!map.example : !List(Word)
  map*256<Word, Word>(#{x} x + 1, Word$[1,2,3,4])

// Fusible map
!map-f*n : {~A : Type, ~B : Type, f : !A -> B} -> ! {list : List(A)} -> List(B)
  new<List(B)>{~P, cons, nil}
  @ list ~> P(-#(map-f.step(~A, ~B, #f))(~n, map-f, self))
  | cons => cons(f(head), map-f(tail))
  | nil  => nil
  * nil<B>

// From 2.2m rewrites to 229k rewrites using map-f
map-f.example
  let list = Word$[1, 2, 3, 4, 5, 6, 7, 8]
  dup list.id   = list.id*256
  dup map  = map-f*256<Word, Word>(#{x} x + 1)
  dup list = rec(*10000, ~List(Word), #map, #list)
  # list.id<Word>(list)

!map.composition*n :
  !{~A : Type
  , ~B : Type
  , ~C : Type
  , f  : !{:B} -> C
  , g  : !{:A} -> B
  , xs : List(A)
  } -> -#(map*n<B,C>(f))(-#(map*n<A,B>(g))(xs)) == -#(map*n<A,C>(#{x}-#(f)(-#(g)(x))))(xs)
  @ xs ~>
    -#(map(step(n), ~B, ~C, f))(-#(map(step(n), ~A, ~B, g))(self)) == -#(map(step(n), ~A, ~C, #{x}-#(f)(-#(g)(x))))(self)
  | cons => 
    cong(
      ~ List(C),
      ~ List(C),
      ~ -#(map(n, ~B, ~C, f))(-#(map(n, ~A, ~B, g))(tail)),
      ~ -#(map(n, ~A, ~C, #{x}-#(f)(-#(g)(x))))(tail),
      ~ {xs} cons<C>(-#(f)(-#(g)(head)), xs),
      ~ map.composition<A, B, C>(f, g, tail))
  | nil =>
    refl<nil>
  * refl<nil>

// :::::::::::::
// :: Zipping ::
// :::::::::::::
  
// Normal zipp
!zipp*n : !{~A : Type, ~B : Type, func : List(A -> B), list : List(A)} -> List(B)
  (@ func ~> List(A) -> List(B)
  | cons => {list}
    @List list ~> List(B)
    | cons => cons<B>(head^(head), zipp<A, B>(tail^, tail))
    | nil  => nil<B>
  | nil => {list}
    nil<B>)(list)
  * nil<B>

// Fusible zipp
!zipp-f*n : !{~A : Type, ~B : Type, func : List(A -> B), list : List(A)} -> List(B)
  new<List(B)>{~P, consf, nilf}
  (@ func ~> { consf : {head : B, tail : List(B)} -> P(cons(~B, head, tail)), nilf  : P(nil<B>)} -> P(-#(zipp-f.step)(~n, zipp-f, ~A, ~B, self, list))
  | cons => {consf, nilf}
    @List list ~> P(-#(zipp-f.step)(~n, zipp-f, ~A, ~B, cons<A -> B>(head, tail), self))
    | cons     => consf(head^(head), zipp-f<A, B>(tail^, tail))
    | nil      => nilf
  | nil => {consf, nilf}
    nilf)(consf, nilf)
  * nil<B>
  
// :::::::::::
// :: Algos ::
// :::::::::::

!reverse.go*n : !{~T : Type, *list : List(T), result : List(T)} -> List(T)
  (@ list ~> List(T) -> List(T)
  | cons  => {result} reverse.go<T>(tail, cons<T>(head, result))
  | nil   => {result} result)(result)

!reverse : {n : Ind} -> dup reverse = reverse.go(n); !{~T : Type, list : List(T)} -> List(T)
  reverse(~T, list, nil<T>)

!concat*n : !{~T : Type, xs : List(T), ys : List(T)} -> List(T)
  (@ xs  ~> List(T) -> List(T)
  | cons => {ys} cons<T>(head, concat<T>(tail, ys))
  | nil  => {ys} ys)(ys)
  * nil<T>

main reverse
