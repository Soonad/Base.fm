import Ind open

T List <A : Type>
| cons {head : A, tail : List(A)}
| nil

head : {~T : Type, default : T, list : List(T)} -> T
  case<List> list
  | cons => head
  | nil  => default
  : T

tail : {~T : Type, list : List(T)} -> List(T)
  case<List> list
  | cons => tail
  | nil  => nil(~T)
  : List(T)

take : {~T : Type, default : T, list : List(T)} -> [x : T, List(T)]
  case<List> list
  | cons => [head, tail]
  | nil  => [default, nil<T>]
  : [x : T, List(T)]

// ::::::::::::::
// :: Identity ::
// ::::::::::::::

// Normal identity
!id*n : !{~A : Type, *list : List(A)} -> List(A)
  case<List> list
  | cons => cons<A>(head, id<A>(tail))
  | nil  => nil<A>
  : List(A)

// Id example
!id.example : !List(Word)
  id*256<Word>(Word$[1,2,3,4])

// Fusible identity
!id-f*n : !{~A : Type, *list : List(A)} -> List(A)
  new<List(A)>{~P, cons, nil}
  case<List> list
  | cons => cons(head, id-f<A>(tail))
  | nil  => nil
  : P(-#(id-f.step)(~n, id-f, ~A, self))

// From 1.7m to 3.2k rewrites by using `id-f` to build the list
id-f.example
  let list = Word$[1, 2, 3, 4, 5, 6, 7]
  dup id   = id*256
  dup id-f = id-f*256
  dup list = rec(*10000, ~List(Word), #id-f<Word>, #list)
  # id<Word>(list)

// :::::::::::::
// :: Mapping ::
// :::::::::::::

// Normal map
!map*n : {~A : Type, ~B : Type, f : !A -> B} -> ! {list : List(A)} -> List(B)
  case<List> list
  | cons => cons<B>(f(head), map(tail))
  | nil  => nil<B>
  : List(B)
  * nil<B>

// Map example
!map.example : !List(Word)
  map*256<Word, Word>(#{x} x + 1, Word$[1,2,3,4])

// Fusible map
!map-f*n : {~A : Type, ~B : Type, f : !A -> B} -> ! {list : List(A)} -> List(B)
  new<List(B)>{~P, cons, nil}
  case<List> list
  | cons => cons(f(head), map-f(tail))
  | nil  => nil
  : P(-#(map-f.step(~A, ~B, #f))(~n, map-f, self))
  * nil<B>

// From 2.2m rewrites to 229k rewrites using map-f
map-f.example
  let list = Word$[1, 2, 3, 4, 5, 6, 7, 8]
  dup id   = id*256
  dup map  = map-f*256<Word, Word>(#{x} x + 1)
  dup list = rec(*10000, ~List(Word), #map, #list)
  # id<Word>(list)

!map.composition*n :
  !{~A : Type
  , ~B : Type
  , ~C : Type
  , f  : !{:B} -> C
  , g  : !{:A} -> B
  , xs : List(A)
  } -> -#(map*n<B,C>(f))(-#(map*n<A,B>(g))(xs)) == -#(map*n<A,C>(#{x}-#(f)(-#(g)(x))))(xs)
  case<List> xs
  | cons => 
    cong(
      ~ List(C),
      ~ List(C),
      ~ -#(map(n, ~B, ~C, f))(-#(map(n, ~A, ~B, g))(tail)),
      ~ -#(map(n, ~A, ~C, #{x}-#(f)(-#(g)(x))))(tail),
      ~ {xs} cons<C>(-#(f)(-#(g)(head)), xs),
      ~ map.composition<A, B, C>(f, g, tail))
  | nil =>
    refl<nil>
  : -#(map(step(n), ~B, ~C, f))(-#(map(step(n), ~A, ~B, g))(self)) == -#(map(step(n), ~A, ~C, #{x}-#(f)(-#(g)(x))))(self)
  * refl<nil>

// :::::::::::::
// :: Zipping ::
// :::::::::::::
  
// Normal zipp
!zipp*n : !{~A : Type, ~B : Type, func : List(A -> B), list : List(A)} -> List(B)
  ( case<List> func
  | cons => {list}
    case<List> list
    | cons => cons<B>(head^(head), zipp<A, B>(tail^, tail))
    | nil  => nil<B>
    : List(B)
  | nil => {list}
    nil<B>
  : List(A) -> List(B))(list)
  * nil<B>

// Fusible zipp
!zipp-f*n : !{~A : Type, ~B : Type, func : List(A -> B), list : List(A)} -> List(B)
  new<List(B)>{~P, consf, nilf}
  ( case<List> func
  | cons => {consf, nilf}
    case<List> list
    | cons => consf(head^(head), zipp-f<A, B>(tail^, tail))
    | nil  => nilf
    : P(-#(zipp-f.step)(~n, zipp-f, ~A, ~B, cons<A -> B>(head, tail), self))
  | nil => {consf, nilf}
    nilf
  : { consf : {head : B, tail : List(B)} -> P(cons(~B, head, tail))
    , nilf  : P(nil<B>)}
    -> P(-#(zipp-f.step)(~n, zipp-f, ~A, ~B, self, list)))(consf, nilf)
  * nil<B>
  
// :::::::::::
// :: Algos ::
// :::::::::::

!reverse.go*n : !{~T : Type, *list : List(T), result : List(T)} -> List(T)
  (case<List> list
  | cons => {result} reverse.go<T>(tail, cons<T>(head, result))
  | nil  => {result} result
  : List(T) -> List(T))(result)

!reverse : {n : Ind} -> dup reverse = reverse.go(n); !{~T : Type, list : List(T)} -> List(T)
  reverse(~T, list, nil<T>)
