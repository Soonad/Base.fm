import Base@0

//  Proving absurds with Empty
//  --------------------------

// Another interesting example comes from the Empty datatype:

// {- From Data.Empty -}
T Empty

// Its code isn’t incomplete, the datatype has zero constructors. This means it is impossible to construct a term t with type Empty, but we can still accept it as a function argument. So, what happens if we pattern match against it?

// absurd.example_0 : {x : Empty} -> ?
//   case/Empty
//   : ?

// The answer is: we can replace ??? by anything, and the program will check. That’s because we technically proved all the demanded cases, so Formality just returns the motive directly as the type of this case expression. That allows us to write a function that returns something absurd:

absurd.example_1 : {e : Empty} -> 1 == 2
  case/Empty e
  : 1 == 2

// If we managed to call it, we’d have a proof that 1 == 2, which is absurd, making Formality inconsistent. But this is fine: prove_1_is_2 can’t ever be called, because we can’t construct a value of type Empty. This is pretty useful, so we have a base-lib function that, given an element of Empty, returns any absurd type:

// {- From Data.Empty -}
absurd.example2 : {e : Empty, ~P : Type} -> P
  case/Empty e
  : P

// The opposite holds too: given an absurd equality, we can make an element of type Empty. Here is an example:

// {- From Data.Bool -}
absurd.example3 : {e : true == false} -> Empty
  unit :: rewrite x
    in case/Bool x
       | true  => Unit
       | false => Empty
       : Type
    with e

// As an exercise, convince yourself why this works.





