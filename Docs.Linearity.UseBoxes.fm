import Base@0
// ### Use boxes

// Formality has another primitive for deep-copying values, boxes. When dealing with data, though, you almost never want to use boxes to perform copies, due to the stratification condition, which essentially segregates the language in levels, blocks communication from higher to lower levels. Regardless, they can still be useful sometimes. See, for example, how `map` is defined for lists:

#boxes.example_0*n : {~A : Type, ~B : Type, f : !A -> B} -> ! {case list : List(A)} -> List(B)
| cons => cons(~B, f(list.head), boxes.example_0(list.tail))
| nil  => nil(~B)
halt: nil(~B)

// Here, `f` is duplicated on level `0`, allowing it to be used multiple times on level `1`. The tradeoff is that, relative to programs on level `1`, `f` must be seen as static. So, if an user input arrives on level `0`, for example, it can't affect the shape of `f`.

// Boxes really shine when implementing control flow like loops and recursion. This will be explained in more details on the next section.