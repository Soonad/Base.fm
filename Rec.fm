// Rec is just the inductive Parigot-Nat (erased to Church-Nat). It has this
// name because it can be used to fuel recursive functions. It is encoded
// manually because the datatype syntax can't express a boxed return type, nor
// use P() inside constructors yet.
Rec : Type
  $ self {
   ~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(call(n))
  , S : ! P(halt)
  }  -> ! P(self)

call : {n : Rec} -> Rec
  new Rec {~P, C, S} =>
  dup C = C
  dup S = S
  dup A = (%n)(~P, #C, #S)
  # C(~n, A)

halt : Rec
  new Rec {~P, C, S} =>
  S

// This "fuels" recursive functions. Here, I use `256` (defined below),
// which gives us a "bound" of 256 calls per recursive function. This can be
// changed to be a very large number (i.e., 2^64 for example).
rec : {~T : Type, call : !{x : T} -> T, halt : !T} -> !T
  dup call = call
  dup halt = halt
  (%r256)(~{r} => T, #{~n} => call, #halt)

// Since `Rec` is just the type of the inductive hypothesis wrapped on self,
// induction itself is just identity as usual.
induce : {n : Rec} -> 
  {~P : {n : Rec} -> Type
  , C : ! {~n : Rec, i : P(n)} -> P(call(n))
  , S : ! P(halt)
  } -> ! P(n)
  %n

twice : {n : Rec} -> Rec
  new Rec {~P, CALL, HALT}
  dup CALL = CALL
  dup HALT = HALT
  let moti = {n} => P(twice(n))
  let CALL = # {~n, i} => CALL(~call(twice(n)), CALL(~twice(n), i))
  let HALT = # HALT
  (%n)(~moti, CALL, HALT)

r256 : Rec
  twice(twice(twice(twice(
  twice(twice(twice(twice(
  call(halt)))))))))

// Runtime fusion on repeated not
main
  let moti = {n}     => Bool@1.Bool
  let call = {~n, x} => Bool@1.not_f(x)
  let halt = Bool@1.true
  (%r256)(~moti, #call, #halt)
