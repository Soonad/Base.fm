import Equal
import Nat

T Bits
| be
| b0(pred : Bits)
| b1(pred : Bits)

bits.not(bs : Bits) : Bits
  case bs
  | be => be
  | b0 => b1(bits.not(bs.pred))
  | b1 => b0(bits.not(bs.pred))
  : Bits

bits.copy(bs : Bits) : [:Bits, Bits]
  case bs
  + bits.copy : Bits -> [:Bits, Bits]
  | be =>
    [be, be]
  | b0 =>
    get [lft, rgt] = bits.copy(bs.pred)
    [b0(lft), b0(rgt)]
  | b1 =>
    get [lft, rgt] = bits.copy(bs.pred)
    [b1(lft), b1(rgt)]
  : [:Bits, Bits]

// ::::::::::::::
// :: Theorems ::
// ::::::::::::::

bits.not_not_is_same(bs : Bits) : Equal(Bits, bits.not(bits.not(bs)), bs)
  case bs
  | be => refl(~Bits, ~be)
  | b0 => cong(
    ~Bits,
    ~Bits,
    ~bits.not(bits.not(bs.pred)),
    ~bs.pred,
    ~b0,
    bits.not_not_is_same(bs.pred))
  | b1 => cong(
    ~Bits,
    ~Bits,
    ~bits.not(bits.not(bs.pred)),
    ~bs.pred,
    ~b1,
    bits.not_not_is_same(bs.pred))
  : Equal(Bits, bits.not(bits.not(bs)), bs)
