// Bits.fm
// =======
// 
// Defines a bitstream, or binary sequence.

import Equal
import Nat

// Definition
// ----------

T Bits
| be
| b0(pred : Bits)
| b1(pred : Bits)

// Functions
// ----------

// Bitwise negation
not_bits(x: Bits) : Bits
  case x
  | be => be
  | b0 => b1(not_bits(x.pred))
  | b1 => b0(not_bits(x.pred))
  : Bits

// Bitwise conjunction
and_bits(x: Bits, y: Bits) : Bits
  case x
  + y : Bits
  | be => be
  | b0 => case y
    + x.pred : Bits
    | be => be
    | b0 => b0(and_bits(x.pred, y.pred))
    | b1 => b0(and_bits(x.pred, y.pred))
  | b1 => case y
    + x.pred : Bits
    | be => be
    | b0 => b0(and_bits(x.pred, y.pred))
    | b1 => b1(and_bits(x.pred, y.pred))

// Bitwise disjunction
or_bits(x: Bits, y: Bits) : Bits
  case x
  + y : Bits
  | be => be
  | b0 => case y
    + x.pred : Bits
    | be => be
    | b0 => b0(or_bits(x.pred, y.pred))
    | b1 => b1(or_bits(x.pred, y.pred))
  | b1 => case y
    + x.pred : Bits
    | be => be
    | b0 => b1(or_bits(x.pred, y.pred))
    | b1 => b1(or_bits(x.pred, y.pred))

// Bitwise exclusive disjunction
xor_bits(x: Bits, y: Bits) : Bits
  case x
  + y : Bits
  | be => be
  | b0 => case y
    + x.pred : Bits
    | be => be
    | b0 => b0(xor_bits(x.pred, y.pred))
    | b1 => b1(xor_bits(x.pred, y.pred))
  | b1 => case y
    + x.pred : Bits
    | be => be
    | b0 => b1(xor_bits(x.pred, y.pred))
    | b1 => b0(xor_bits(x.pred, y.pred))

// Bitwise right shift
right_shift_bits(n: Nat, x: Bits) : Bits
  case n
  + x : Bits
  | zero => x
  | succ => case x
    + n.pred : Nat
    | be => be
    | b0 => right_shift_bits(n.pred, x.pred)
    | b1 => right_shift_bits(n.pred, x.pred)

// Bitwise left shift
left_shift_bits(n: Nat, x: Bits) : Bits
  case n
  + x : Bits
  | zero => x
  | succ => case x
    + n.pred : Nat
    | be => be
    | b0 => left_shift_bits(n.pred, b0(b0(x.pred)))
    | b1 => left_shift_bits(n.pred, b0(b1(x.pred)))

// Increment
inc_bits(x: Bits) : Bits
  case x
  | be => b1(be)
  | b0 => b1(x.pred)
  | b1 => b0(inc_bits(x.pred))

// Addition
add_bits(x: Bits, y: Bits) : Bits
  case x
  + y : Bits
  | be => be
  | b0 => case y
    + x.pred : Bits
    | be => be
    | b0 => b0(add_bits(x.pred, y.pred))
    | b1 => b1(add_bits(x.pred, y.pred))
  | b1 => case y
    + x.pred : Bits
    | be => be
    | b0 => b1(add_bits(x.pred, y.pred))
    | b1 => b0(inc_bits(add_bits(x.pred, y.pred)))

bits_to_nat(x: Bits) : Nat
  case x
  | be => zero
  | b0 => double(bits_to_nat(x.pred))
  | b1 => succ(double(bits_to_nat(x.pred)))

nat_to_bits(n: Nat) : Bits
  case n
  | zero => be
  | succ => inc_bits(nat_to_bits(n.pred))

copy_bits(bs: Bits) : [:Bits, Bits]
  case bs
  + copy_bits : Bits -> [:Bits, Bits]
  | be =>
    [be, be]
  | b0 =>
    get [lft, rgt] = copy_bits(bs.pred)
    [b0(lft), b0(rgt)]
  | b1 =>
    get [lft, rgt] = copy_bits(bs.pred)
    [b1(lft), b1(rgt)]

// Theorems
// --------

double_negation_bits(x: Bits) : not_bits(not_bits(x)) == x
  case x
  | be => refl(__)
  | b0 => cong(_____ double_negation_bits(x.pred))
  | b1 => cong(_____ double_negation_bits(x.pred))
  : not_bits(not_bits(x)) == x
