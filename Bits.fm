import Equal
import Nat

T Bits
| be
| b0(pred : Bits)
| b1(pred : Bits)

bits.not(bs : Bits) : Bits
  case bs
  | be => be
  | b0 => b1(bits.not(bs.pred))
  | b1 => b0(bits.not(bs.pred))
  : Bits

// ::::::::::::::
// :: Theorems ::
// ::::::::::::::

bits.not_not_is_same(bs : Bits) : Equal(Bits, bits.not(bits.not(bs)), bs)
  case bs
  | be => refl(~Bits, ~be)
  | b0 => cong(
    ~Bits,
    ~Bits,
    ~bits.not(bits.not(bs.pred)),
    ~bs.pred,
    ~b0,
    bits.not_not_is_same(bs.pred))
  | b1 => cong(
    ~Bits,
    ~Bits,
    ~bits.not(bits.not(bs.pred)),
    ~bs.pred,
    ~b1,
    bits.not_not_is_same(bs.pred))
  : Equal(Bits, bits.not(bits.not(bs)), bs)
