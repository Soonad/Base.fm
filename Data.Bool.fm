import Data.Empty
import Data.Unit

T Bool
| true
| false

// ::::::::::::::::::::::
// :: Simple functions ::
// ::::::::::::::::::::::

copy : {case b : Bool} -> [:Bool, Bool]
| true  => [true, true]
| false => [false, false]

not : {case b : Bool} -> Bool
| true  => false
| false => true

and : {case a : Bool, b : Bool} -> Bool
| true  => b
| false => false

or : {case a : Bool, b : Bool} -> Bool
| true  => true
| false => b

nand : {case a : Bool, b : Bool} -> Bool
| true  => not(b)
| false => true

nor : {case a : Bool, b : Bool} -> Bool
| true  => false
| false => not(b)

xor : {case a : Bool, case b : Bool} -> Bool
| true  true  => false
| true  false => true
| false true  => true
| false false => false

xnor : {case a : Bool, case b : Bool} -> Bool
| true  true  => true
| true  false => false
| false true  => false
| false false => true

// :::::::::::::::::::::::
// :: Fusible functions ::
// :::::::::::::::::::::::

// Not with runtime fusion
not-f : {b : Bool} -> Bool
  new(~Bool){~P, true, false}
    case/Bool b
    | true  => false
    | false => true
    : P(not-f(b))

// If-then-else
bool_if : {b : Bool, ~P : Type, T : P, F : P} -> P
  (%b)(~{b}P, T, F)

// ::::::::::::::
// :: Theorems ::
// ::::::::::::::

true_isnt_false : {e : true == false} -> Empty
  unit :: rewrite x
    in (case/Bool x | true => Unit | false => Empty : Type)
    with e

false_isnt_true : {e : false == true} -> Empty
  true_isnt_false(sym(~e))

different_elem : {a : Bool} -> [b : Bool ~ {:a == b} -> Empty]
  case/Bool a
  | true  => [false ~ true_isnt_false]
  | false => [true ~ {e : false == true} => true_isnt_false(sym(~e))]
  : [b : Bool ~ {:a == b} -> Empty]

demorgan_0 :
  { case a : Bool
  , case b : Bool
  } -> not(or(a,b)) == and(not(a), not(b))
| true  true  => refl(~false)
| true  false => refl(~false)
| false true  => refl(~false)
| false false => refl(~true)

demorgan_1 :
  { case a : Bool
  , case b : Bool
  } -> not(and(a,b)) == or(not(a), not(b))
| true  true  => refl(~false)
| true  false => refl(~true)
| false true  => refl(~true)
| false false => refl(~true)

nand.demorgan : {case a : Bool, case b : Bool} -> nand(a,b) == not(and(a,b))
| true  true  => refl(~false)
| true  false => refl(~true)
| false true  => refl(~true)
| false false => refl(~true)

nor.demorgan : {case a : Bool, case b : Bool} -> nor(a,b) == not(or(a,b))
| true  true  => refl(~false)
| true  false => refl(~false)
| false true  => refl(~false)
| false false => refl(~true)

xnor_is_eq :
  { case a : Bool
  , case b : Bool
  } -> bool_if(xnor(a,b), ~Type, a == b, Not(a == b))
| true true   => refl(~true)
| true false  => true_isnt_false
| false true  => false_isnt_true
| false false => refl(~false)

xor_is_neq :
  { case a : Bool
  , case b : Bool
  } -> bool_if(xor(a,b), ~Type, Not(a == b), a == b)
| true true   => refl(~true)
| true false  => true_isnt_false
| false true  => false_isnt_true
| false false => refl(~false)

and.associative : 
  { case a : Bool
  , case b : Bool
  , case c : Bool
  } -> and(and(a,b),c) == and(a,and(b,c))
| true  true  true   => refl(~true)
| true  true  false  => refl(~false)
| true  false true   => refl(~false)
| true  false false  => refl(~false)
| false true  true   => refl(~false)
| false true  false  => refl(~false)
| false false true   => refl(~false)
| false false false  => refl(~false)

or.associative :
  { case a : Bool
  , case b : Bool
  , case c : Bool
  } -> or(or(a,b),c) == or(a,or(b,c))
| true  true  true   => refl(~true)
| true  true  false  => refl(~true)
| true  false true   => refl(~true)
| true  false false  => refl(~true)
| false true  true   => refl(~true)
| false true  false  => refl(~true)
| false false true   => refl(~true)
| false false false  => refl(~false)

and.left_identity : {b : Bool} -> and(true, b) == b
  refl(~b)

and.right_identity : {case a : Bool} -> and(a, true) == a
| true  => refl(~true)
| false => refl(~false)

or.left_identity : {a : Bool} -> or(false, a) == a
  refl(~a)

or.right_identity : {case a : Bool} -> or(a, false) == a
| true  => refl(~true)
| false => refl(~false)
