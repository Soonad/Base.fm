import Equal
import Nat

// The inductive hypothesis on perfect binary trees. Erases to Church.
IBinTree : Type
  ${self}
  ( ~P      : IBinTree -> Type
  , ibranch : ! (~k : -IBinTree, a : P(k), b : P(k)) -> P(ibranch(k))
  , ifinale : ! P(ifinale)
  ) -> ! P(self)

ibranch(k : IBinTree) : IBinTree
  new(~IBinTree) (~P, ibranch, ifinale) =>
  dup ibranch = ibranch
  dup ifinale = ifinale
  dup endfold = (use(k))(~(x) => P(x), #ibranch, #ifinale)
  # ibranch(~k, endfold, endfold)

ifinale : IBinTree
  new(~IBinTree) (~P, ibranch, ifinale) =>
  dup ibranch = ibranch
  dup ifinale = ifinale
  # ifinale

ind2_depth(i2 : IBinTree) : !Nat
  (use(i2))(~(x) => Nat, #(~i,a,b) => succ(a), #zero)

t0  : IBinTree; ifinale
t1  : IBinTree; ibranch(t0)
t2  : IBinTree; ibranch(t1)
t3  : IBinTree; ibranch(t2)
t4  : IBinTree; ibranch(t3)
t5  : IBinTree; ibranch(t4)
t6  : IBinTree; ibranch(t5)
t7  : IBinTree; ibranch(t6)
t8  : IBinTree; ibranch(t7)
t9  : IBinTree; ibranch(t8)
t10 : IBinTree; ibranch(t9)
t11 : IBinTree; ibranch(t10)
t12 : IBinTree; ibranch(t11)
t13 : IBinTree; ibranch(t12)
t14 : IBinTree; ibranch(t13)
t15 : IBinTree; ibranch(t14)
t16 : IBinTree; ibranch(t15)
t17 : IBinTree; ibranch(t16)
t18 : IBinTree; ibranch(t17)
t19 : IBinTree; ibranch(t18)
t20 : IBinTree; ibranch(t19)
t21 : IBinTree; ibranch(t20)
t22 : IBinTree; ibranch(t21)
t23 : IBinTree; ibranch(t22)
t24 : IBinTree; ibranch(t23)
t25 : IBinTree; ibranch(t24)
t26 : IBinTree; ibranch(t25)
t27 : IBinTree; ibranch(t26)
t28 : IBinTree; ibranch(t27)
t29 : IBinTree; ibranch(t28)
t30 : IBinTree; ibranch(t29)
t31 : IBinTree; ibranch(t30)
t32 : IBinTree; ibranch(t31)
