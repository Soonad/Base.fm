import Data.Function

// A functor consists of...
T Contravariant {F : Type -> Type, s : {A : Type} -> Setoid(F(A))}
| contravariant

  // A contravariant mapping function
  { contramap :
    { ~A : Type
    , ~B : Type
    , f  : A -> B
    , x  : F(B)
    } -> F(A)

  // Satisfying the identity law
  , identity :
    {~A  : Type
    , fa : F(A)
    } -> case/Setoid s(A) as s | setoid =>
           contramap(~A, ~A, id(~A),fa) == fa
         : Type

  // Satisfying the composition law
  , composition :
    { ~A : Type
    , ~B : Type
    , ~C : Type
    , g  : B -> C
    , f  : A -> B
    , fc : F(C)
    } -> let con1 = contramap(~A, ~C)
         let con2 = contramap(~A, ~B)
         let con3 = contramap(~B, ~C)
         case/Setoid s(A) as s | setoid =>
           s.R(con1({x} g(f(x)), fc), con2(f, con3(g, fc)))
         : Type
  }

// A generic map for functors
contramap :
  { ~F : Type -> Type
  , ~s : {A : Type} -> Setoid(F(A))
  , case con : Contravariant(F,s)
  , ~A : Type
  , ~B : Type
  ,  f : A -> B
  } -> F(B) -> F(A)
| contravariant => con.contramap(~A, ~B, f)

//// We can modify all elements of a functor to a fixed element `x`
contramap_const :
  { ~F : Type -> Type
  , ~s : {A : Type} -> Setoid(F(A))
  , case con : Contravariant(F,s)
  , ~A : Type
  , ~B : Type
  , x : B
  } -> F(B) -> F(A)
| contravariant => con.contramap(~A, ~B, const(~A, ~B, x))


