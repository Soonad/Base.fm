
//  Self Encoding
//  -------------

// Interestingly, none of the features above are part of Formality’s type theory. Instead, they are lightweight syntax-sugars that elaborate to plain-old lambdas. To be specific, a datatype is encoded as is own inductive hypothesis, with “self-types”. For example, the Bool datatype desugars to:

Bool : Type
  $self
  { ~P    : {x : Bool} -> Type
  , true  : P(true)
  , false : P(false)
  } -> P(self)

true : Bool
  new(~Bool){~P, true, false} true

false : Bool
  new(~Bool){~P, true, false} false

case_of : {b : Bool, ~P : {x : Bool} -> Type, t : P(true), f : P(false)} -> P(b)
  (%b)(~P, t, f)

// Here, $self ..., new(~T) val and %b are the type, introduction, and elimination of self-types, respectively. You can see how any datatype is encoded under the hoods by asking fm to evaluate its type, as in, fm Data.Bool@0/Bool -W (inside the fm_modules directory). The -W flag asks Formality to not evaluate fully, since Bool is recursive. While you probably won’t need to deal with self-encodings yourself, knowing how they work is valuable, since it allows you to express types not covered by the built-in syntax.

// TODO: write a brief explanation on how Self-Types work (although I think it should be self-explanatory from this example!).
