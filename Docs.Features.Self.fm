// ### Self Types

// Formality also has Self Types, which allow the type of a term to access its
// own value:

// syntax          | description
// --------------- | -----------------------------------------------------------
// `$self T(self)` | `T` is a type that can access its own value
// `new(~T) t`     | Constructs an instance of a `T` with value `t`
// `(%t)`          | Consumes a self-type `t`, giving its type access to its value

// Note that Self Types are not the same as recursive types. Recursive types
// allow the type to access *itself*. For example:

N_Words : {n : Word} -> Type
  if n .< 2:
    Word
  else:
    [:Word, N_Words(n - 1)]

// The type above allows you to create a list of `N` words:

main : N_Words(4)
  [0, 1, 2, 3]

// Self Types allow a type to access *its own value*. This has many uses.
// Suppose that you wanted to create a pair of identical words:

self.SameWords : Type
  $self [:Word, :Word, fst(self) == fst(snd(self))]

self.same_words_0 : self.SameWords 
  new(~self.SameWords) [0, 0, refl(~0)]

self.same_words_1 : self.SameWords 
  new(~self.SameWords) [1, 1, refl(~1)]

self.same_words_2 : self.SameWords 
  new(~self.SameWords) [2, 2, refl(~2)]

// Notice how the `self.SameWords` type has access to values of its terms. So,
// when we instantiate `self.same_words_0`, the `self` variable on the type is
// replaced by `[0, 0, refl(~0)]`, which becomes `[:Word, :Word, 0 == 0]`,
// allowing us to write the last element a `refl(~0)`. Of course, in this case,
// this effect could be achieved with dependent pairs:

self.SameWordsB : Type
  [x : Word, y : Word, x == y]

self.same_words_b_0 : self.SameWordsB
  [0, 0, refl(~0)]

self.same_words_b_1 : self.SameWordsB
  [1, 1, refl(~1)]

self.same_words_b_2 : self.SameWordsB
  [2, 2, refl(~2)]

// But what is interesting is that Self Types are more expressive than
// dependent pairs. We could, for example, make an "insanely dependent" pair
// where the first element depends on the second, and vice-versa:

self.Insane : Type
  $self
  [: [a : Word, (a * 2) == fst(snd(self))],
     [b : Word, b == fst(fst(self)) + 1]]
  
self.insane : self.Insane
  new(~self.Insane)
  [[1, refl(~2)],
   [2, refl(~2)]]

// This define the type of pairs [a,b] such that `a * 2 = b` and `b = a + 2`.
// Notice the mutual reference. The only possible way to make it is with `a =
// 1` and `b = 2`, which is the solution to the equation above.

// Self Types are used by Formality to create inductive datatypes. This is
// explained in more details on the tutorial section.
