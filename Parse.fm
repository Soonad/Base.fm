import Maybe
import Nat
import String
import Unit

// Consumes a String and returns the rest and the parsed value, if any
Parser(A) : Type
  (str: String) -> [: String, Maybe(A)]

// Consumes nothing, returns `x`
return(A; x: A) : Parser(A)
  (str) => [str, some(A; x)]

// Errors
throw(A;) : Parser(A)
  (str) => [str, none(A;)]

// Monadic composition of two parsers
bind(A; B; x: Parser(A), f: A -> Parser(B)) : Parser(B)
  (str) =>
    get [str, res] = x(str)
    case res
    + str : String
    | none => [str, none(_)]
    | some => f(res.value, str)
    : [: String, Maybe(B)]

// Consumes nothing, returns the next character
peek : Parser(Char)
  (str) =>
    case str
    | nil  => [nil(_), none(_)]
    | cons =>
      cpy str.head = str.head
      [cons(_ str.head, str.tail), some(_ str.head)]
    : [: String, Maybe(Char)]

// Parses one character if possible
next : Parser(Char)
  (str) =>
    case str
    | nil  => [nil(_), none(_)]
    | cons => [str.tail, some(_ str.head)]
    : [: String, Maybe(Char)]

// If first is `chr`, return true and consumes it
match_one(chr: Char) : Parser(Bool)
  (str) =>
    case str
    | nil  => [nil(_), some(_ false)]
    | cons =>
      (if chr .==. str.head then
        (str.head: Char, str.tail: String) => [
          str.tail,
          some(_ true)]
      else
        (str.head: Char, str.tail: String) => [
          cons(_ str.head, str.tail),
          some(_ false)
        ])(str.head, str.tail)
    : [: String, Maybe(Bool)]

// Parses exactly this character
parse_exact(chr: Char) : Parser(Unit) {
  var val = next;
  if chr .==. val then #{
    return unit;
  } else #{
    throw;
  }
}

// Skip whitespaces
skip_whites : Parser(Unit) {
  var found_white = match_one(' ');
  case found_white
  | true  => skip_whites
  | false => { return unit; }
}

// Parses a nat on the form SSS...Z
parse_nat : Parser(Nat) {
  var chr = next;
  if chr .==. 'S' then {
    var pred = parse_nat;
    return succ(pred);
  } else {
    return zero;
  }
}

// Parses a nat tuple on the form [SSS...Z,SSS...Z]
parse_nats : Parser([:Nat, Nat]) {
  parse_exact('[');
  var nat0 = parse_nat;
  parse_exact(',');
  var nat1 = parse_nat;
  parse_exact(']');
  return [nat0, nat1];
}
