import Maybe
import Nat
import String
import Unit

// Consumes a String and returns the rest and the parsed value, if any
Parser(A) : Type
  (str: String) -> [: String, Maybe(A)]

// Consumes nothing, returns `x`
return(A; x: A) : Parser(A)
  (str) => [str, some(A; x)]

// Errors
throw(A;) : Parser(A)
  (str) => [str, none(A;)]

// Monadic composition of two parsers
bind(A; B; x: Parser(A), f: A -> Parser(B)) : Parser(B)
  (str) =>
    get [str, res] = x(str)
    case res
    + str : String
    | none => [str, none(_)]
    | some => f(res.value, str)
    : [: String, Maybe(B)]

// Consumes nothing, returns the next character
peek : Parser(Char)
  (str) =>
    case str
    | nil  => [nil(_), none(_)]
    | cons =>
      cpy str.head = str.head
      [cons(_ str.head, str.tail), some(_ str.head)]
    : [: String, Maybe(Char)]

// Parses one character if possible
next : Parser(Char)
  (str) =>
    case str
    | nil  => [nil(_), none(_)]
    | cons => [str.tail, some(_ str.head)]
    : [: String, Maybe(Char)]

// If first is `chr`, return true and consumes it
match_one(chr: Char) : Parser(Bool)
  (str) =>
    case str
    | nil  => [nil(_), some(_ false)]
    | cons =>
      (if chr .==. str.head then
        (str.head: Char, str.tail: String) => [
          str.tail,
          some(_ true)]
      else
        (str.head: Char, str.tail: String) => [
          cons(_ str.head, str.tail),
          some(_ false)
        ])(str.head, str.tail)
    : [: String, Maybe(Bool)]
    
// Parses exactly this character
parse_exact(chr: Char) : Parser(Unit)
  do<Unit>
    bind val : Char = next
    if chr .==. val then
      return(_ unit)
    else
      throw(_)

// Skip whitespaces
skip_whites : Parser(Unit)
  do<Unit>
    bind found_white : Bool = match_one(' ')
    case found_white
    | true  => skip_whites
    | false => return(_ unit)
    : Parser(Unit)

// Parses a nat on the form SSS...Z
parse_nat : Parser(Nat)
  do<Nat>
    bind chr : Char = next
    if chr .==. 'S' then do<Nat>
      bind pred : Nat = parse_nat
      return(_ succ(pred))
    else
      return(_ zero)

// Parses a nat tuple on the form [SSS...Z,SSS...Z]
parse_nats : Parser([:Nat, Nat])
  do<[:Nat, Nat]>
    bind skip : Unit = parse_exact('[')
    bind nat0 : Nat  = parse_nat
    bind skip : Unit = parse_exact(',')
    bind nat1 : Nat  = parse_nat
    bind skip : Unit = parse_exact(']')
    return(_ [nat0, nat1])

// Evaluates a parser
run_parser(A; parser : Parser(A), str : String) : Maybe(A)
  snd(parser(str))
