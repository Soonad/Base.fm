// The inductive hypothesis on nats. Erases to Church.
Ind : Type
  ${self}
  {~P     : {r : Ind} -> Type} ->
  {step   : ! {~r : -Ind, i : P(+r)} -> P(step(+r))} ->
  ! {base : P(base)} ->
    P(self)

step : {r : Ind} -> Ind
  new(~Ind){~P, step}
  dup step = step
  dup func = (use(r))(~{x} P(x) :: Type, #step)
  # {base}
    step(~%r, func(base))

base : Ind
  new(~Ind){~P, step}
  dup step = step
  # {base}
    base

// Since `Ind` is just the type of the inductive hypothesis wrapped on self,
// then induction on `Ind` is just identity.
ind :
  {n     : Ind
  , ~P   : {n : Ind} -> Type
  , step : ! {~n : -Ind, i : P(+n)} -> P(step(+n))
  , stop : ! P(base)
  } -> ! P(n)
  dup step = step
  dup stop = stop
  dup loop = (use(n))(~{x} P(x) :: Type, #step)
  # loop(stop)

// Induction without indices is just recursion.
rec : {r : Ind, ~T : Type, step : !{x : T} -> T, base : !T} -> !T
  dup step = step
  dup base = base
  dup loop = (use(r))(~{r} => T :: Type, #{~n} => step)
  # loop(base)

// Doubles the number of steps of an `ind`.
twice : {n : Ind} -> Ind
  new(~Ind) {~P, STEP}
  dup STEP = STEP
  let moti = {n} P(twice(n)) :: Type
  let STEP = {~n, i} => STEP(~%step(twice(+n)), STEP(~%twice(+n), i))
  dup loop = (use(n))(~moti, #STEP)
  # {base} loop(base)

// Adds two Inds.
plus : {a : Ind, b : Ind} -> Ind
  new(~Ind) {~P, S}
  dup S = S
  dup A = (use(a))(~{a} => P(plus(a, b)) :: Type, #{~n, h} => S(~%plus(+n, b), h))
  dup B = (use(b))(~{b} => P(plus(base, b)) :: Type, #{~n, h} => S(~%plus(base, +n), h))
  # {z} => A(B(z))

