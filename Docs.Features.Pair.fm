import Base

// ### Pair

// Native pairs store two elements of possibly different types.

// syntax               | description
// -------------------- | -------------------------------------
// `[x : A, B(x)]`      | The type of a `pair`
// `[a, b]`             | Creates a `pair` with elements `a` and `b`
// `fst(p)`             | Extracts the first element of a `pair`
// `snd(p)`             | Extracts the second element of a `pair`
// `get [a, b] = p` ... | Extracts both elements of a `pair`

// Creating:
pair.example_0 : [:Word, Word]
  [1, 2]

// Extracting the first element:
pair.example_1 : Word
  let pair = [1, 2]
  fst(pair)

// Extracting the second element:
pair.example_2 : Word
  let pair = [1, 2]
  fst(pair)

// Extracting both elements:
pair.example_3 : Word
  let pair  = [1, 2]
  get [a,b] = pair
  a + b

// Nesting to the left:
pair.example_4 : [:[:Word, Word], String]
  [[1, 2], "Hello Word!"]

// Nesting to the right:
pair.example_5 : Word
  let triple  = [1, 2, 3] // same as [1, [2, 3]]
  get [x,y,z] = triple
  x + y + z

// Erased (first element):
pair.example_6 : [~: Word, Word]
  [~1, 2] // the number "1" is erased from runtime

// Erased (second element):
pair.example_7 : [: Word ~ Word]
  [1 ~ 2] // the number "2" is erased from runtime

// Notably, the second element of a pair can depend on the value of the first.
pair.example_8 : [x : Word, (if x: Word else: Bool)]
  [0, true] // if you change 0 to 1, the second element must be a Word.
